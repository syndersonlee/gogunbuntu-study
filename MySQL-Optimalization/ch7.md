# ch7 고성능을 위한 인덱싱

- 인덱스 최적화는 쿼리 성능을 향상 시키는 좋은 방법
- 인덱스는 종종 실제 성능의 주요한 문제가 됨

## 인덱싱 기본

- MySQL에서 인덱스는 책의 색인 처럼 동작
- 인덱스는 테이블에 있는 하나 이상의 열의 값을 포함
- ORM의 도구에 의존하더라도 인덱싱에 의존
    - 대부분의 케이스에서 올바른 쿼리를 생성하지만
    - 기본 키 조회 같은 간단한 쿼리가 아닌 이상 기타 쿼리에서는 문제가 발생 가능

### 인덱스 유형

- 서버 계층이 아닌 스토리지 엔진 계층에서 인덱스 구현
- MySQL이 지원하는 지원하는 가장 일반적으로 사용하는 두 가지 인덱스 유형
    - B트리 인덱스
    - 적응형 해시 인덱스

#### B-트리 인덱스

- NDB Cluster 엔진은 BTREE로 레이블 지정 / InnoDB는 B+ 트리를 사용
- B-트리 인덱스는 스토리지 엔진이 원하는 데이터를 찾기 위해 전체 테이블을 스캔할 필요 없음
    - 데이터 엑세스 속도 향상
    - 리프 페이지는 인덱싱 되어 있는 데이터에 대한 포인터를 가지고 있음
- 적응형 해시 인덱스
    - 일부 인덱스 값이 매우 자주 엑세스되고 있음을 감지 시 메모리 해시 인덱스 구축

#### B-트리 인덱스를 사용할 수 있는 쿼리 유형

- 전체 값 일치
- 맨 왼쪽 접두사 일치
- 값 범위 일치
- 한 부분을 정확히 일치시키고 다른 부분의 범위와 일치
- 인덱스 전용 쿼리 (커버링 인덱스)

#### 인덱스 제한 사항

- 인덱싱 가장 왼쪽에서 조회가 시작되지 않으면 유용하지 않음
- 인덱스 열을 건너뛸 수 없음
- 스토리지 엔진은 첫 번째 범위 조건의 오른쪽 열을 사용한 액세스 최적화 불가능

#### 풀 텍스트 인덱스

- 인덱스 값을 직접 비교하는 것이 아닌 텍스트에서 키워드를 찾는 특수 유형의 인덱스
- 단순한 WHERE 매개 변수 매칭 X -> 검색 엔진이 하는 작업과 유사

### 인덱스의 이점

- B-트리 인덱스는 데이터를 정렬된 순서로 저장
- 이점
    - 서버가 검사해야하는 데이터 양 감소
    - 정렬 및 임시 테이블 생성 방지
    - 랜덤 I/O를 순차 I/O로 변환

## 고성능을 위한 인덱싱 전략

### 프리픽스 인덱스 및 인덱스 선택성

- 전체 값 대신 처음 몇 개의 문자를 인덱싱 하는 방법
    - 공간 절약 및 성능 향상 가능
    - 고유 인덱스 선택성이 1일 경우, 더 좋을 순 없음
    - 프리픽스 형태의 인덱스의 경우 우수한 성능을 제공하는 경우가 많음
    - 매우 긴 VARCHAR이나 TEXT 열은 반드시 정의 필요

### 다중 열 인덱스

### 좋은 열 순서 선택하기

### 클러스터형 인덱스

### 커버링 인덱스

### 인덱스 스캔을 사용한 정렬

### 중복과 이중 인덱스

### 사용하지 않는 인덱스

## 인덱스와 테이블 유지 관리

### 테이블 손상 찾기 및 복구

### 인덱스 통계 업데이트

### 인덱스 및 데이터 단편화 줄이기