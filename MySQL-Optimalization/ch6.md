# ch6 스키마 설정과 관리
## 최적의 데이터 유형과 선택

- 데이터 유형에 관련 없이 가지는 특징
    - 작을 수록 좋음
        - 더 작은 CPU 캐시 공간, 메모리를 사용
    - 단순할 수록 좋음
        - 데이터 작업을 처리하는 데에 더 적은 CPU 주기를 필요
        - 데이터 처리 시 리소스 낭비가 적음
    - 가급적 NULL 회피
        - nullable한 칼럼의 경우 스토리지 낭비가 심함
- 첫 번째로 일반 유형 클래스 선택
- 특정 유형을 그 다음으로 선택

### 정수

- 정수와 실수 두가지 타입으로 *TINYINT*, *SMALLINT*, *MEDIUMINT*, *INT*, *BIGINT* 존재
    - 각각 8, 16, 24, 32, 64비트 사용
- *UNSIGNED* 속성 가질 수 있음
- 정수 계산에는 일반적으로 *BIGINT* 사용 / DECIMAL, DOUBLE 같은 집계 함수는 예외

### 실수

- *FLOAT* 및 *DOUBLE* 부동 소수점 연산으로 근사 값 지원
    - *FLOAT*는 4바이트 / *DOUBLE*은 8바이트
- 정밀한 연산 요구 시 *DECIMAL* 사용 필요
- 더 정확한 연산 필요시 BIGINT로 저장 후 배수로 저장하는 것이 나음

#### 문자열 유형

##### VARCHAR와 CHAR 유형

- VARCHAR
    - 가변 길이 문자열
    - 공간 절약의 필요성이 있고 조각화의 문제가 발생하지 않는 경우
    - UTF-8 등의 인코딩 비추천
- CHAR
    - 고정 길이 문자열

- MD5로 암호화 할 경우 CHAR이 적당 (길이가 고정이므로)

##### BLOB과 TEXT 유형

- 대용량 텍스트를 바이너리 혹은 문자열로 저장
- 고유 엔진에서 특별한 외부 공간에 저장 가능
- BLOB과 TEXT의 차이점은 TEXT에만 문자 집합과 데이터 정렬 존재

##### 문자열 대신 ENUM 사용하기

- 열을 ENUM을 변환한 후 조인이 더 빠름, ENUM열을 VARCHAR 열로 조인하는 속도는 느림
- 다만 열을 변환했을 경우 테이블 크기가 1/3로 작아짐

### Date와 Time 유형

- DATETIME
    - 1마이크로초 정밀도로 정수 압축 시간으로 저장
- TIMESTAMP
    - 1970년 이후 UNIX 타임스탬프 형식으로 저장
    - DATETIME보다 훨씬 크기가 작음
    - 2038년 까지 사용 가능

### 비트 팩 데이터 유형

- BIT
    - 참거짓을 단일 열에 저장할 수 있는 기술
    - ASCII CODE를 저장하는 방식으로 보면 됨
- SET
    - 참/거짓을 많이 저장해야하는 경우
- 어플리케이션 권한을 저장하는 ACL을 제어할 때 사용

### JSON 데이터

- RDBMS에 저장하는 것은 올바른 형태는 아님
- SQL 버전이 더 적은 용량 사용
- 

### 식별자 선택

- **식별자**는 행을 참조하고 행을 고유하도록 하는 역할
- UNSIGNED 같은 속성을 사용해서 정확하게 일치하도록 해야함

##### 정수 타입

- AUTO_INCREMENT 등을 같이 사용가능
- 적합한 크기를 가지고 있어야 함

##### ENUM과 SET

- 식별자에는 미적합

##### 문자열 타입

- 가급적 미사용 추천
- UUID()나 MD5() 같은 임의의 문자열에도 조심할 필요가 있음
- 쿼리 지연 가능성
- UUID 같은 경우 *BINARY(16)* 열에 저장하거나 HEX() 함수로 검색

### 특별한 유형의 데이터

- IPv4의 경우 가끔 VARCHAR(15)를 통해 저장
- 다만 이는 unsigned로 저장하는 것이 원래 맞음

## MySQL의 스키마 설계 문제

### 너무 많은 열
### 너무 많은 조인
### 지나친 ENUM 사용
### 위장한 ENUN
### NULL의 지나친 배제

## 스키마 관리

### 데이터 저장소 플랫폼의 일부인 스키마 관리