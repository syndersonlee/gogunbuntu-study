# Part 2 개발자에게 도움이 되는 테스트 만들기

## ch4 좋은 단위 테스트의 4대 요소

- 회귀 방지
- 리팩토링 내성
- 빠른 피드백
- 유지 보수성

### 회귀 방지

- 코드 수정 이후 기능이 의도하지 않은 대로 작동 하는 경우를 방지
    - 중요한 지표
        - 테스트 중에 실행되는 코드의 양
        - 코드 복잡도
        - 코드의 도메인 유의성
- 결론
    - 회귀 방지를 위해서는 테스트가 최대한 많은 코드를 실행 해야 함

### 리팩터링 내성

- 테스트가 실패가 되지 않고 코드를 리팩토링 가능 한지 확인
- 기반 코드를 수정 시 실 오류에 무관하게 테스트 코드에 에러가 발생하는 경우 : <b>거짓 양성</b>
- 이에 따라 구현은 수정해도 동작은 유지 가능 한 특성 : <b>리팩토링 내성</b>
- 리팩토링 내성이 없는 경우?
    - 테스트가 타당한 이유가 없이 실패해도 무시하게 되는 케이스 발생
    - 테스트 스위트에 대한 신뢰가 줄어 들어 리팩토링을 줄어들고 코드 변경을 최소화 함

### 거짓 양성의 원인

- 세부 구현 사항을 테스트에서 분리
- 하위 렌더링 클래스를 직접 구현하여 테스트를 진행할 경우 테스트 세부 사항과 결합
- 위의 방법의 경우 하위 구현 방법의 교체 될 경우 테스트가 깨질 가능성이 높음

### 책에서 제시하는 올바른 테스트

- 테스트 단계를 세부 구현 단계 1,2,3단계라고 가정할 때 책에서는 1,2,3단계에 대한 각각의 테스트를 옳지 못하다고 생각
- 최종 결과만을 테스트 하기 위해 1,2,3단계를 거친 결과 값만을 점검하는 것을 권장
- 메소드 파라미터가 추가되거나 늘어나는 케이스 정도를 제외하면 거짓 양성이 거의 없음


### 테스트 정확도

| 오류 유형 표 | 작동 | 고장 |
| -- | -- | -- |
| 테스트 통과 | 올바른 추론 (참 음성) | 2종 오류 (거짓 음성) |
| 테스트 실패 | 1종 오류 (거짓 양성) | 올바른 추론 |


- 테스트의 의미는 버그가 있음을 잘 나타내는 가와 버그가 없음을 잘 나타내는 두 지표가 매우 중요
- 테스트 정확도는 발견된 버그 수에 비례하고, 허위 경보 발생 수에 반비례

### 거짓 양성과 거짓 음성의 특징

- 거짓 양성은 초기에는 개발자의 기억에 의존하여 초기에는 중요하지 않을 것처럼 보임
- 프로젝트 사이즈가 커지고 코드 베이스가 커질 수록 리팩토링이 필요하고 이에 따라 거짓 양성을 발생시키는 테스트 코드는 아무런 역할을 하지 못함
- 프로젝트 사이즈가 커지기 전에 많은 프로젝트가 끝나기 때문에 이를 인지 못하는 경우가 많음


### 빠른 피드백과 유지 보수성

- 테스트가 오래 걸리는 경우 버그가 늦게 눈에 띄고 자주 실행이 어려움 (엔드 투 엔드 테스트)
- 유지비가 많이 드는 테스트는 두가지가 있음
    - 테스트 코드 라인이 클 경우
    - 테스트에 외부 존속성이 높아 실행이 까다로운 경우

### 4대 요소의 저울질

- 단위 테스트의 4가지 요소를 모두 고려해야 좋은 테스트
- 하나가 0점이면 다른 것들이 높아도 좋지 않은 코드

#### 엣지 케이스 : 엔드 투 엔드 케이스

- 모든 요소가 다 훌륭한 테스트지만, 피드백이 매우 느리기 때문에 테스트 확인까지 느리다는 단점이 있음

#### 엣지 케이스 : 간단한 케이스

- 코드와 로직이 매우 간단하기 때문에 회귀 방지가 없음

#### 엣지 케이스 : 깨지기 쉬운테스트

- SQL문을 그대로 넣는 케이스를 예시로 실행이 빠르고 회귀 또한 캐치가 가능하지만, 리팩토링 진행했을 때 테스트가 바로 실패하는 것을 볼 수 있음

#### 결론

- 리팩토링 내성의 경우 일반적으로 0 or all의 특성을 가지고 있는 경우가 많음
- 회귀 방지와 빠른 피드백 사이는 조절이 가능
- 일반적으로 빠른 리팩토링 특성을 포기하지 않으면서 두 가지 중에 절충을 하는 것이 Best Practice

### 자동화 테스트의 개념

- 대부분의 테스트의 숫자는 아래의 규칙이 일반적이고 숫자가 적을 수록 유저 친화적인 테스트
   - 엔드 투 엔드 테스트 < 통합 테스트 < 단위 테스트
- 어느 상태에서도 리팩토링 내성은 포기하지 않는 것이 중요
    - 회귀 방지 우선 : <b>엔드 투 엔드 테스트</b>
    - 절충 : <b>통합 테스트</b>
    - 빠른 피드백 우선 : <b>단위 테스트</b>
- 기본적인 CRUD 위주로 작업이 많을 수록 단위 테스트와 통합 테스트만 존재하는 직사각형 행태로 변함

#### 블랙박스 테스트와 화이트 박스 테스트 개념

- 블랙 박스 테스트 : 기능 검증
- 화이트박스 테스트 : 내부 구현 검증

| | 회귀 방지 | 리팩토링 내성 |
| -- | -- | -- |
| 화이트박스 테스트 | 좋음 | 나쁨 |
| 블랙박스 테스트 | 나쁨 | 좋음 |

- 복잡한 알고리즘 이외에는 블랙박스 테스트가 디폴트로 사용하는 것이 좋음

## ch5 목과 테스트 취약성

### 목과 스텁의 구분

- 테스트 대역의 구분
    - Mock : 외부로 나가는 상호 작용을 검사하는 데 사용, 상태 변경을 위한 의존성 호출
        - Mock : 프레임 워크가 도와주는 케이스
        - Spy : 수동으로 작성하는 케이스
    - Stub : 내부로 들어오는 상호 작용을 모방, 상태 조회를 위한 의존성 호출
        - Stub : 시나리오마다 다른 값이 들어오도록 구현한 케이스
        - Dummy : Null 및 기타 Primitive 값으로 코딩된 값
        - Fake : Stub과 비슷하지만, 존재하지 않은 의존성을 구축하여 사용
- Mock은 Sut과의 의존성을 모방 및 검사, Stub은 모방만 진행

### 도구로서의 목과 테스트 대역으로서의 목

- 도구로서의 Mock은 수단으로서 사용하는 Mock이기 때문에 이는 Stub으로도 사용할 수 있음
- 테스트 대역의 Mock은 외부에 이메일 호출 같은 의미있는 응답이 없는 사이드 이펙트

### 상호 작용 검증

- 스텁으로 상호 작용을 검증 할 경우 *과잉명세*를 유의
    - 최종 결과가 아닌 사항을 검

### 목과 스텁 그리고 명령과 조회

| 명령 | 사이드 이펙트 초래 | 반환 값 없음 | Mock |
| -- | -- | -- | -- |
| 조회 | 사이드 이펙트 없음 | 반환 값 존재 | Stub |

### 식별할 수 있는 동작 그리고 공개 API

- 제품 코드의 두 가지 분류
    - 공개 API or 비공개 API
    - 식별 할 수 있는 동작 or 구현 세부 사항
- 코드는 두 가지 중에 하나가 되어야 한다
    - 목표 달성에 도움 되는 **연산** 노출
    - 목표 달성에 도움 되는 **상태** 노출
- 공개 API는 식별할 수 있는 동작과 일치 해야 함
- 아래처럼 결합하는 게 이상적
    - 공개 API와 식별 가능한 동작
    - 구현 세부 사항과 비공개 API


#### 코드 예시 분석

- public 객체 내부에 Name에 대한 제약 사항이 공개 되어 있음
- 또한 Setter가 외부에 의존성을 띄기 떄문에 내부에 해당 데이터를 숨기고 내부적으로 호출 해야 함
- 잘 짜인 코드에서는 Setter에 대한 호출을 private로 숨기고 비공개
- 잘 짜인 코드는 일반적으로 클래스에서 호출해야 할 1보다 크지 않음

### 잘 설계된 API와 캡슐화

- 코드 복잡도는 지속적으로 증가하고 이에 대한 유지 보수성을 늘리기 위해서는 캡슐화가 필요
- 구현 세부 사항은 숨기고 기능과 결합 하도록 코드를 작성

|  | 식별 할 수 있는 동작 | 구현 세부 사항 |
| -- | -- | -- |
| 공개 | 좋음 | 나쁨 |
| 비공개 | 해당 없음 | 좋음 |

### 목과 테스트 취약성과의 인과 관계

- 어플리케이션 계층은 도메인 계층과 분리
- 어플리케이션 계층의 역할
    - 데이터베이스 조회 및 도메인 클래스 인스턴스 구체화
    - 인스턴스 연산 호출 / 타 어플리케이션과의 소통
    - 데이터 베이스 저장

### 육각형 아키텍처

- 도메인 서비스가 어플리케이션 서비스를 둘러 싸고 있음
- 외부에서 메시지 버스, SMTP 서비스, 서드 파티 시스템이 외부 통신을 진행하는 시스템
- 이 시스템에서 가장 중요한 3가지
    - 도메인 계층과 어플리케이션 서비스 계층 관심사 분리
    - 어플리케이션 내부 통신
    - 어플리케이션 간의 통신
- 식별 가능한 동작은 기본적으로 바깥에서 안으로 흐름
- Mock을 사용하는 이유는 시스템과 외부 어플리케이션 간의 통신 패턴을 확인 하기 위해 사용
- 또한 리팩토링을 진행한 이후에도 통신 유형을 유지하기 위함

### 외부 의존성 Mocking 처리

- 고전파에서는 의존성을 피할 것을 권고
- 공유 의존성이 외부에 있을 경우 테스트가 매우 복잡해지기 떄문에 테스트 준비가 복잡
- 어플리케이션이 프록시 같은 역할 을 할 경우, 클라이언트에 영향을 미치지 않음
- 또한 어플리케이션 내부의 DB를 사용할 경우 Mock을 대체해서 사용 가능

## ch6 단위 테스트 스타일

### 단위 테스트의 세 가지 스타일

- 출력 기반 테스트
- 상태 기반 테스트
- 통신 기반 테스트

#### 출력 기반 스타일 정의

- 입력에 대한 출력에 대한 검증으로 **함수형 프로그래밍**과 같은 형식

#### 상태 기반 스타일 정의

- 작업 완료 후 시스템 상태를 확인하는 검증
- DB 및 File System에 대한 Status를 검증

#### 통신 기반 검증

- 협력자 Class를 Mocking 처리한 후 해당 메소드를 호출 하는지 확인하는 검증
- 테스트 시 협력자를 잘 호출하는 여불ㄹ 체크

### 단위 테스트 스타일 비교

- 회귀 방지와 피드백 속도 측면으로 비교
- 회귀 방지의 3가지 지표
    - 테스트 코드의 양
    - 코드 복잡도
    - 도메인 유의성
- 테스트 속도는 거의 동일한 수준

### 리팩터링 내성 지표로 스타일 비교

- 출력 기반 테스트는 거짓 양성 방지가 가장 우수
- 상태 기반 테스트는 거짓 양성이 되기 쉬움
    - 테스트와 제품 결합도가 클수록 더 심함
- 통신 기반 테스트는 거짓 양성에 가장 취약
    - 상호 작용 테스트는 금지에 가까움


### 유지 보수성 지표로 스타일 비교

- 단위 테스트의 유지비 기준
    - 테스트 이해의 어려움 - 크기
    - 테스트 실행의 어려움 - 외부 의존성의 개수

#### 출력 기반 테스트

- 짧고 간결하여 유지보수가 쉬움
- 의존성을 다루지 않아 좋음

#### 상태 기반 테스트

- 상태 검증보다 많은 공간을 차지하여 유지보수가 어려움
- 상태의 종류에 따른 검증부가 많아짐
- 클래스 전체 에 대한 전체로 비교하면 좋으나 값으로 되어있는 클래스가 아닐 경우 *코드 오염*의 가능성 존재

#### 통신 기반 테스트

- 유지 보수 점수가 낮고, 테스트 대역과 상호 작용 검증 설정 필요
- Mock이 Chain 형태로 존재하면 테스트가 더 커지고 어려움

#### 결론

- 출력 기반 > 상태 기반 > 통신 기반

### 함수형 아키텍처의 이해

- 입출력이 명확하고 숨은 입출력이 없이 메소드 상에 전부 정의 된 경우
- 함수형 메소드가 없는 것
    - 사이드 이펙트
    - 예외
    - 내외부 참조

#### 함수형 아키텍처

- 결정을 내리는 코드 : 함수형 코어
    - 사이드 이펙트가 없는 수학적 함수
    - 결정을 생성하고 논리적인 로직 구현
- 결정에 따라 작용하는 코드 : 가변 셀
    - 외부 혹은 내부 상호 작용
    - 모든 입력 수집
    - 결정을 사이드 이펙트로 변환

#### 함수형 아키텍처 vs 육각형 아키텍처

- 차이점
    - 사이드 이펙트를 비즈니스 가장자리로 밀어냄 - **함수형 아키텍처**
    - 사이드 이펙트를 도메인에 포함시켜도 문제가 없음 - **육각형 아키텍처**

### 코드 분석

- 로직을 절차적 프로그래밍으로 최초에 구현
- 외부 의존성 (ex.FileSystem)을 생성자에 파라미터로 주입
- 해당 파라미터를 Mocking 처리를 하고 이를 생성자의 변수로 넣음

#### 추가 리팩토링

- 외부 의존성에 대한 변동 메소드를 Return으로 회신
- 해당 회신 변동 메소드를 별도 클래스로 파서 구현
- 실제 비지니스 로직(Persiter)에서는 내부의 구조를 파헤치지 않고 호출만 진행
- 이 때 테스트는 도메인 객체 대해서 생성만 담당하고 값 회산 정보만 비교

#### 추가 개발

- 추가 개발 상황이 들어와도 해당 외부 의존성 변동 처리하는 메소드만 갈아 끼우는 형태로 개발 가능

### 함수형 아키텍처의 단점

- 숨은 입력이 발생한 경우 함수형 메소드 적용 불가
    - ex. 방문 횟수 제한
- 해결책
    - 서비스 전면에 방문자 접근 레벨 수집
        - 성능 저하 및 외부 시스템 분리 가능
    - 새로운 메소드로 실제 메소드 전에 필터링
        - 분리가 다소 완화되는 형태
- 도메인 모델에 DB를 의존하는 것은 무조건 좋지 않음

#### 성능 단점

- 성능 향상이 크게 떨어지지 않는 한 유지보수성이 더 좋음

#### 코드 베이스 증가

- 초기에 작성은 어렵지만 함수형 프로그래밍이 궁극저긍로 코드 복잡도가 앚아지고 유지 보수성이 낮아짐
- 순수성에는 너무 많은 비용을 투자할 필요가 없음

## ch7 리팩터링

### 리팩토링 코드 식별

#### 코드의 네 가지 유형

- 2차원 분류
    - 복잡도 또는 도메인 유의성
        - 순환 복잡도 : 1 + <분기점 수>
        - 복잡한 코드와 도메인 유의성 코드가 단위 테스트에서 가장 이롭고 둘은 독립적임
    - 협력자 수
        - 협력자 수가 많은 경우 테스트 비용이 많이 듬
        - 도메인 모델은 외부 협력자 사용 X

| | 협력자 수 적음 | 협력자 수 많음 |
| -- | -- | -- |
| 복잡도 및 도메인 유의성 적음 | 간단한 코드 | 컨트롤러 |
| 복잡도 및 도메인 유의성 많음 | 도메인 모델 및 알고리즘 | 지나치게 복잡한 코드|

- 위 그래프에서 지나치게 복잡한 코드가 리팩토링 대상
    - 알고리즘과 컨트롤러로 구분

#### 험블 객체 패턴 사용하여 복잡한 코드 분할

- 험블 객체를 매개로 의존성과 로직을 분리
- 테스트는 로직만 진행
- 효과
    - SRP 원칙을 지킴
    - 코드베이스의 총 통신 수를 줄여 연결을 줄이고 테스트 용이성 향상

### 가치 있는 단위 테스트를 위한 리팩터링

- 최초 코드 분석
    - 절차적 프로그래밍으로 DB에서 사용자 정보와 조직 정보를 검색
    - 조직의 도메인 이름과 직원 수를 검색 후 사용자 유형 설정
    - 해당 정보에 따라 조직 정보 업데이트 및 사용자 업데이트
    - 메시지 버스 알림 전송

#### 암시적 의존성 명시적 만들기

- 외부 의존성을 인터페이스 처리 후 이를 도메인 객체에 Injection 처리
- 이 때 해당 외부 의존성을 Mocking 처리
- 변경점
    - 각 객체에 대한 협력자 클래스를 따로 분리

#### 어플리케이션 복잡도 낮추기

- 변경점
    - 도메인 클래스를 인스턴스화 하는 팩토리 클래스 작성하여 생성시 호출

#### Company 클래스 재정의

- 회사 관련 로직만 처리하는 Company 클래스만 별도로 분리하여 처리하도록 함
- 회사 관련 이메일 처리 및 생성 로직을 User에 대한 기존에 로직과 동일하게 가져감

### 최적의 단위 테스트 커버리지 분석

#### 도메인 객체와 유틸리티 코드 테스트

- 도메인 객체에 대한 코드는 도메인의 값과 내부 값을 비교하여 확인

#### 전제 조건 테스트 

- 도메인 유의성에 있는 모든 전제 조건을 테스트 하면 좋지만 없는 것을 테스트 하는 것은 시간 낭비

### 컨트롤러에서 조건부 조직 처리

- 중간 단계에 대한 결과 값으로 그다음 프로세스가 결정 되는 경우
    - 의사 결정 프로세스를 더 세분화하고 각 단계별 컨트롤러 수행
    
- 세 가지 특성이 중요
    - 도메일 모델 테스트 유의성 : 협력자 수와 유형
    - 컨트롤러 단순성 : 의사 결정 분기 지점
    - 성능 : 외부 의존성 호출 수
- 이 중 두 가지 특성을 선택하여 개발해야 함
    - 컨트롤러 단순성 + 도메인 모델 테스트 유의성 : 읽기와 쓰기를 비즈니스 연산 가장자리로 밀어냄
    - 도메인 모델 테스트 유의성 + 성능 : 의사 결정 프로세스 단계 세분화
    - 컨트롤러 단순성 + 성능 : 도메인 모델에 프로세스 의부 의존성 주입
- 성능은 중요하고, 2번은 복잡하기 때문에 스킵
- 3번째를 선택해야 하는데 이때 컨트롤러 복잡도를 확인해야 함

#### CanExecute/Execute 패턴 사용

- 첫 번째 옵션
    - 데이터 준비 이후 의사 결정 및 데이터 처리
    - 성능 저하 감수 필요
- 두 번째 옵션
    - IsEmailConfirmed 확인을 User에서 컨트롤러로 옮김
    - 의사 결정 프로세스가 분리 되는 케이스

#### 도메인 이벤트를 통해 도메인 모델 변경 사항 추적

- 객체에 해당 내용을 Queue처럼 담는 작업을 도메인 메소드 객체에서 진행
- 컨트롤러 단에서는 실제로 그 데이터를 처리
- 테스트 시에는 컬럭션 내부의 값과 실제 값을 비교하여 정상적인지 확인
