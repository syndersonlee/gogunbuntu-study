# 5장 복제

복제가 필요한 여러가지 이유?

1. 지리적으로 사용자와 가깝게 유지하여 지연 시간 줄임
2. 장애가 발생해도 지속적으로 동작할 수 있도록 가용성 증대
3. 읽기 질의를 제공하는 장비의 수를 확장하여 읽기 처리량 증대

노드 간의 변경을 복제하기 위한 3가지 알고리즘

1. 단일 리더
2. 다중 리더
3. 리더 없는 복제

## 리더와 팔로워

일반적인 해결책은 <b> 리더 기반 복제 </b> 

- 리더를 지정하고 쓰기를 진행 할 때 리더로 요청을 보냄
- 팔로워에 해당하는 저장소가 새로운 데이터를 기록할 때마다 리더에서 팔로워에게 전송
- 클라이언트가 읽기 시 리더 또는 임의의 팔로워에게 질의 수행

### 동기식 대 비동기식 복제

- 복제가 동기식으로 발생하는 지 비동기식으로 발생하는 지 여부
- 장점
    - 팔로워가 리더와 최신 데이터에 대해 일관성을 가짐
- 단점
    - 팔로워가 응답하지 않으면 쓰기 처리 또한 불가
- 위의 이유로 모든 팔로워가 동기 식인 것은 비현실적
- 리더 복제 중 하나는 동기 / 하나는 비동기식으로 구현 - <b> 반동기식 구현 </b>
- 일반적인 리더 복제의 경우 완전한 비동기식으로 구현
    - 쓰기가 이루어져도 완전한 지속성을 미보장
    - 다만 팔로워와 관계 없이 쓰기 작업 수행 가능

### 새로운 팔로워 설정

새로운 팔로워가 리더의 데이터 복제본을 그대로 가지고 있는 지 보장 확인 방법

1. 리더의 데이터베이스 스냅샷을 일정 시점에 가져옴
2. 스냅샷을 팔로워 노드에 복사
3. 팔로워는 리더에 연결 하여 스냅 샷 이후 모든 데이터 변경을 요청
4. 스냅샷 이후의 백로그를 모두 따라 잡았을 경우 처리 가능

### 노드 중단 처리

리더 기반 복제에서 고가용성을 달성하는 방법이란?

#### 팔로워 장애 : 따라잡기 복구

- 로컬에 보관된 로그 확인
- 결함 이전의 트랜잭션 확인 후 리더에게 데이터 요청하여 따라잡기 진행

#### 리더 장애 : 쟁애 복구

- 팔로워를 리더로 승격하고 변경 후 재설정 필요 - failover

자동 장애 복구 방법은?

1. 리더가 장애인지 판단 (timeout으로 조치)
2. 새로운 리더를 선출 (제어 노드를 통해 임명)
3. 새로운 리더 사용을 위해 시스템을 재설정

이 때 발생 할 수 있는 부작용

- 이전 리더의 쓰기를 일부 수신 못할 수도 있음
- 유효하지 않은 데이터베이스 승격 / 이로 인한 정보 유출 등의 가능성
- 리더가 2개 이상 발생 가능 - <b>스플릿 브레인</b>
    - 데이터 분실 및 오염 가능
- 타임 아웃이 너무 짧을 시 장애 복구가 상황을 더 악화 시킬 수 있음

### 복제 로그 구현

리더 기반 복제의 내부 동작 방식

#### 구문 기반 복제

- 리더는 모든 쓰기 요청을 구문을 기록하고 실행 (SQL)

복제가 깨질 수 있는 다양한 사례는?

- NOW()나 RAND() 같은 비결정적 함수 호출 시
- UPDATE와 같이 데이터 내부 데이터 기반 프로세스의 경우 정확한 순서로 실행하지 않으면 발생
- 트리거 및 스토어드 프로시저에서 완벽하게 하지 않으면 부수 효과 발생 가능

위 사례에서 비결정적 함수를 호출하여 고정값 반환 하도록 할 수는 있지만 에지 케이스 발생 가능

#### 쓰기 전 로그 배송

1. SS테이블 및 LSM 트리의 경우 로그 세그먼트는 작게 유지되고 백그라운드로 가비지 컬렉션
2. 개별 디스크 블록에 덮어 쓰는 B트리의 경우 쓰기 전 로그에 쓰기 때문에 색인 복원 가능

- 위 두 케이스의 경우 append-only 바이트 열이기 때문에, 복제 서버 구축 가능
- 가장 큰 단점은 제일 저수준의 데이터 기술
- 리더와 팔로워 DB버전을 다르게 가져갈 수 없음
    - 이 방법은 업그레이드 시 중단 현상을 야기

#### 논리적(로우) 로그 복제

복제 로그를 다른 형태로 저장 -> 논리적 로그

- 모든 칼럼의 새로운 값을 포함
- 삭제된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보를 포함
- 테이블에 기본키가 없다면 모든 칼럼은 예전 값을 로깅
- 논리적 로그 형식은 외부 어플리케이션에서 파싱하기 쉬움

-> 이를 <b>변경 데이터 캡처</b>라 부름

#### 트리거 기반 복제

- 오라클의 OGG같은 경우 데이터베이스 로그를 읽어 어플리케이션이 데이터를 변경 할수 있게 함
- Trigger 혹은 Stored Procedure을 사용하기도 함
- 트리거 기반 복사는 다른 복사보다는 제한 사항이 더 많이 발생

## 복제 지연 문제

- 확장성과 지연 시간 때문에 복제를 진행하기도 함

읽기 확장 아키텍처

- 팔로워를 추가함으로써 읽기 전용으로 활용
- 위 방식은 비동기 방식으로 사용
- 위 방식에서는 약간의 지연때문에 데이터 불일치가 일어나나 최종적으로는 리더와 일치하기 때문에 최종적 일관성을 보임

### 자신이 쓴 내용 읽기

자신이 쓴 글이 늦게 반영된다면 사용자는 유실되었다고 생각할 가능성이 있음 - <b>쓰기 후 읽기 일관성</b> 필요

- 수정한 내용은 리더에서 읽고 그 밖은 팔로워에서 읽음
- 갱신 후 1분 동안은 리더에서 모든 읽기 수행
- 복제 서버에서 최신 내용이 아닌 경우에는 질의를 대기 (타임 스탬프 활용)

여러 디바이스에서 읽기 일관성이 필요한 경우

- 메타 데이터를 중앙집중식 관리
- 리더에서 읽어야 할 접근법이라면 사용자 디바이스 요청을 동일한 데이터센터로 라우팅

### 단조 읽기

비동기식 팔로워에서는 시간이 거꾸로 흐를 수도 있음 -> 두번째 지연된 팔로워가 쓰기를 알지 못하는 경우

- 단조 읽기
    - 데이터를 읽을 때는 최종적 일관성 보다는 더 강한 보장
    - 하나의 데이터를 읽을 때 같은 레플리카 서버에서만 읽게 하는 방법

### 일관된 순서로 읽기

다른 파티션에 저장되는 데이터 때문에 사용자는 다른 상태로 존재하는 데이터의 파티션을 확인 할 수 있음

### 복제 지연을 위한 해결책

- 올바른 작업 수행을 위해 데이터베이스를 신뢰 할 수 있게 하기 위해 <b>트랜잭션</b>을 사용하여 강력한 보장 제공

## 다중 리더 복제

리더 기반 복제의 단점

- 리더에 연결 할 수 없다면, 데이터베이스에 쓰기를 할 수 없음
- 쓰기 허용하는 노드를 하나 이상 두는 것 = <b> 다중 리더 설정 - 마스터/마스터, 액티브/액티브 복제 </b>

### 다중 리더 복제의 사용 사례

다중 리더는 복잡도 때문에 사용하지 않지만 아래 케이스의 경우 사용

#### 다중 데이터 센터 운영

- 다중 리더 설정에는 하나의 데이터 센터에서 하나의 리더를 가지고 있음
- 하위 팔로워와 리더 간의 관계는 리더-팔로워 복제 사용
- 리더와 리더 간에는 변경 사항을 복제

단일 리더 설정과 다중 리더 설정 -> 다중 데이터 배포에서 이뤄지는 과정

- 성능
    - 인터넷을 통한 리더 복제가 이루어지기 때문에, 지연으로 인한 발생 문제로 인해 사용자에게 숨김
- 데이터센터 중단 내성
    - 하나의 데이터센터가 고장 나면 장애 복구를 위해 다른 데이터센터에서 팔로워를 리더로 승진
    - 센터 간 독립적으로 동작하기 때문에, 고장난 데이터 센터가 온라인으로 돌아오면 복제를 따라 잡음
- 네트워크 문제 내성
    - 인터넷을 통해 처리되기 때문에 비연결 상태에서도 쓰기 처리를 진행 할 수 있도록 함

문제점

- 동일 데이터를 동시에 다른 DB에서 변경하는 경우
- 설정상의 실수나 자동 증가 키, 트리거, 무결성의 제약에서 문제가 발생 가능

#### 오프라인 작업을 하는 클라이언트

인터넷 연결이 끊어진 경우에도 작업이 동작해야하는 경우

- 온라인 회의 경우
    - 로컬에서 비동기 방식으로 수행
    - 인터넷 연결 접근이 가능해 진 시점에 복제가 이뤄지도록 수행

#### 협업 편집

- 로컬 복제 서버에 적용하고 동일한 문서를 편집 하는 방법
- 

### 쓰기 충돌 다루기
### 다중 리더 복제 토폴로지

## 리더 없는 복제

### 노드가 다운 됐을 때 데이터베이스에 쓰기
### 정족수 일관성의 한계
### 느슨한 정족수와 암시된 핸드 오프
### 동시 쓰기 감지
