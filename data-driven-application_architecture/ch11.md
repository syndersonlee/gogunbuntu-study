# ch11 스트림 처리

- 일반적인 이벤트 처리는 입력이 완료되어야 출력이 시작
- 일괄 처리 같이 입력 값이 큰 경우 출력 값이 시작 할 수 없음
- 따라서 이를 점진적으로 처리하는 기법을 스트림 처리라 명명

## 이벤트 스트림 전송

- 레코드는 스트림에서는 **이벤트**라고 불리는 형태로 불림
- 이진 형태 혹은 JSON 형태로 input 값을 저장하고 이를 출력
- input에 해당하는 주체를 **producer** / output에 해당하는 주체를 **consumer**로 명명
- 또한 폴링 방식은 비용이 크므로, 이벤트 발생 시 consumer에게 전달하는 **트리거** 형식을 사용

### 메시징 시스템

- 메시징 시스템 상에서 해결 해야하는 두 가지 키워드
    - consumer 속도가 producer이 빠를 경우 - **backpressure(배압현상)**
    - 노드가 죽거나 일시적으로 멈춤 현상이 생길 경우 처리 방법

#### 생산자에서 소비자로 메시지를 직접 전달하기

- 대부분의 메시징 시스템은 직접 전달
    - UDP 멀티캐스트는 신뢰성이 낮은 UDP를 사용하지만 복구가 가능
    - ZeroMQ는 TCP/IP 상에서 브로커 없이 Pub/Sub 모델 구현
    - StatsD, BruBeck는 UDP모델을 사용하여 모니터링
    - 서비스 노출 시 RPC나 HTTP 요청을 보낼 수 있음
- 다만 위의 시스템은 어플리케이션 중 일부가 오프라인이 되거나 네트워크 상에서 패킷이 유실 될 경우 문제가 발생 할 수 있음

#### 메시지 브로커

- producer와 consumer가 중간에 broker에 데이터를 보관하는 형태로 사용 가능
- 소비자는 일반적으로 비동기로 동작
- 위 브로커는 메모리 혹은 디스크로 시스템에 따라 다름

#### 메시지 브로커와 데이터베이스 비교

- 메시지 브로커는 명시적으로 삭제하기 전까지 보관하지만 전달 후 삭제한다는 점에서 DB와 다름
- 브로커는 큐의 크기가 상당히 작음
- 브로커는 토픽의 부분 집합을 구독하는 형태
- 질의 시점의 스냅샷을 기준으로 진행

#### 복수 소비자

- 주요 패턴 두 가지
    - 로드 밸런싱
        - consumer group 상에서 consumer를 임의로 지정
        - 메시지 처리 비용이 비쌈
    - 팬 아웃
        - 모든 consumer에게 전달
- 두 패턴은 동시 사용 가능

#### 확인 응답과 재전송

- 브로커는 컨슈머가 데이터를 받았을 경우 **확인 응답**을 통해 이를 확인
- 다만 데이터 수신 도중 consumer가 중간에 죽을 경우 메시지 수신 과정에서 순서가 지켜지지 않을 수 있음
    - 위 문제는 인과성 있는 로직에서 문제가 발생 가능

### 파티셔닝된 로그

- 메시징 시스템 상에서는 DB처럼 메시지를 지속성 있게 저장하는 것이 아님
- 이에 따라 메시지 복구가 어려움
- 지속성 있는 저장과 짧은 지연 시간 + 알림 시스템을 조합할 수 있는 내용 = **로그 기반 메시지 브로커**

#### 로그를 사용한 메시지 저장소

- 생산자가 보낸 메시지는 브로커의 가장 마지막에 append하는 방식으로 구현
- 모든 브로커는 메시지 내에 오프셋이라고 단조 증가 순번을 부여
- 디스크를 쓸 때보다 처리량을 높히기 위해서 **파티셔닝** 이라는 방법을 수행

#### 로그 방식과 전통적인 메시징 방식의 비교

- 로그 방식 접근법은 팬 아웃 방식을 제공하여 독립적으로 로그를 읽을 수 있도록 처리
- 각 파티션에 메시지를 전부 전달하고 이를 각 파티션에서 소비
- 특정 메시지가 느리면 파티션 전체의 메시지 처리가 지연

#### 소비자 오프셋

- 소비자의 현재 오프셋은 큰 오프셋을 가진 메시지는 아직 처리하지 않은 메시지
- **로그 순차 번호**를 사용하여 커넥션이 끊어졌을 경우 다시 복제 재개 할 수 있도록 처리
- 메시지 브로커는 데이터베이스 리더처럼 동자갛고 소비자는 팔로워 처럼 동작
- 소비자 노드에 장애가 발생하면 소비자의 파티션을 할당하고 마지막 오프셋 부터 메시지를 처리
- 다만 record를 실패했을 경우 이를 중복 처리 할 가능성 존재

#### 디스크 공간 사용

- 로그를 계속 추가한다면, 디스크 공간을 전부 사용하게 됨으로 오래된 데이터 순서대로 삭제
- 오랜된 메시지 순서대로 버리는 것을 **원형 버퍼** or **링 버퍼**라고 명명
- 큐가 작을 때는 빠르지만 디스크에 기록하기 시작하면 매우 느려짐

#### 소비자가 생산자를 따라갈 수 없을 때

- 위 사항에서 선택지 3가지가 존재
    - 메시지 버리기
    - 버퍼링
    - 배압 적용
- 로그 저장 방식은 버퍼링에 속함
- 전통적 메시지 브로커에서는 consumer가 죽으면, 큐를 삭제 하지 않을 경우 불필요한 메시지 누적

#### 오래된 메시지 재생

| 분류 | AMQP, JMS | 로그 기반 메시지 브로커 | 
| -- | -- | -- |
| 메시지 처리 기법 | 작업 처리 후 브로커 내 메시지 제거 | 파일을 읽는 형태 |
| 사이드 이펙트 | 메시지 원복 불가 | consumer offset 이동 |

- 로그 기반 메시지 브로커는 메시징 시스템 내에서 많은 시도 가능

## 데이터베이스와 스트림

### 시스템 동기화 유지하기
### 변경 데이터 캡처
### 이벤트 소싱
### 상태와 스트림 그리고 불변성

## 스트림 처리

### 스트림 처리와 사용
### 시간에 관한 추론
### 스트림 조인
### 내결함성