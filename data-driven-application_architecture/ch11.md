# ch11 스트림 처리

- 일반적인 이벤트 처리는 입력이 완료되어야 출력이 시작
- 일괄 처리 같이 입력 값이 큰 경우 출력 값이 시작 할 수 없음
- 따라서 이를 점진적으로 처리하는 기법을 스트림 처리라 명명

## 이벤트 스트림 전송

- 레코드는 스트림에서는 **이벤트**라고 불리는 형태로 불림
- 이진 형태 혹은 JSON 형태로 input 값을 저장하고 이를 출력
- input에 해당하는 주체를 **producer** / output에 해당하는 주체를 **consumer**로 명명
- 또한 폴링 방식은 비용이 크므로, 이벤트 발생 시 consumer에게 전달하는 **트리거** 형식을 사용

### 메시징 시스템

- 메시징 시스템 상에서 해결 해야하는 두 가지 키워드
    - consumer 속도가 producer이 빠를 경우 - **backpressure(배압현상)**
    - 노드가 죽거나 일시적으로 멈춤 현상이 생길 경우 처리 방법

#### 생산자에서 소비자로 메시지를 직접 전달하기

- 대부분의 메시징 시스템은 직접 전달
    - UDP 멀티캐스트는 신뢰성이 낮은 UDP를 사용하지만 복구가 가능
    - ZeroMQ는 TCP/IP 상에서 브로커 없이 Pub/Sub 모델 구현
    - StatsD, BruBeck는 UDP모델을 사용하여 모니터링
    - 서비스 노출 시 RPC나 HTTP 요청을 보낼 수 있음
- 다만 위의 시스템은 어플리케이션 중 일부가 오프라인이 되거나 네트워크 상에서 패킷이 유실 될 경우 문제가 발생 할 수 있음

#### 메시지 브로커

- producer와 consumer가 중간에 broker에 데이터를 보관하는 형태로 사용 가능
- 소비자는 일반적으로 비동기로 동작
- 위 브로커는 메모리 혹은 디스크로 시스템에 따라 다름

#### 메시지 브로커와 데이터베이스 비교

- 메시지 브로커는 명시적으로 삭제하기 전까지 보관하지만 전달 후 삭제한다는 점에서 DB와 다름
- 브로커는 큐의 크기가 상당히 작음
- 브로커는 토픽의 부분 집합을 구독하는 형태
- 질의 시점의 스냅샷을 기준으로 진행

#### 복수 소비자

- 주요 패턴 두 가지
    - 로드 밸런싱
        - consumer group 상에서 consumer를 임의로 지정
        - 메시지 처리 비용이 비쌈
    - 팬 아웃
        - 모든 consumer에게 전달
- 두 패턴은 동시 사용 가능

#### 확인 응답과 재전송

- 브로커는 컨슈머가 데이터를 받았을 경우 **확인 응답**을 통해 이를 확인
- 다만 데이터 수신 도중 consumer가 중간에 죽을 경우 메시지 수신 과정에서 순서가 지켜지지 않을 수 있음
    - 위 문제는 인과성 있는 로직에서 문제가 발생 가능

### 파티셔닝된 로그

- 메시징 시스템 상에서는 DB처럼 메시지를 지속성 있게 저장하는 것이 아님
- 이에 따라 메시지 복구가 어려움
- 지속성 있는 저장과 짧은 지연 시간 + 알림 시스템을 조합할 수 있는 내용 = **로그 기반 메시지 브로커**

#### 로그를 사용한 메시지 저장소

- 생산자가 보낸 메시지는 브로커의 가장 마지막에 append하는 방식으로 구현
- 모든 브로커는 메시지 내에 오프셋이라고 단조 증가 순번을 부여
- 디스크를 쓸 때보다 처리량을 높히기 위해서 **파티셔닝** 이라는 방법을 수행

#### 로그 방식과 전통적인 메시징 방식의 비교

- 로그 방식 접근법은 팬 아웃 방식을 제공하여 독립적으로 로그를 읽을 수 있도록 처리
- 각 파티션에 메시지를 전부 전달하고 이를 각 파티션에서 소비
- 특정 메시지가 느리면 파티션 전체의 메시지 처리가 지연

#### 소비자 오프셋

- 소비자의 현재 오프셋은 큰 오프셋을 가진 메시지는 아직 처리하지 않은 메시지
- **로그 순차 번호**를 사용하여 커넥션이 끊어졌을 경우 다시 복제 재개 할 수 있도록 처리
- 메시지 브로커는 데이터베이스 리더처럼 동자갛고 소비자는 팔로워 처럼 동작
- 소비자 노드에 장애가 발생하면 소비자의 파티션을 할당하고 마지막 오프셋 부터 메시지를 처리
- 다만 record를 실패했을 경우 이를 중복 처리 할 가능성 존재

#### 디스크 공간 사용

- 로그를 계속 추가한다면, 디스크 공간을 전부 사용하게 됨으로 오래된 데이터 순서대로 삭제
- 오랜된 메시지 순서대로 버리는 것을 **원형 버퍼** or **링 버퍼**라고 명명
- 큐가 작을 때는 빠르지만 디스크에 기록하기 시작하면 매우 느려짐

#### 소비자가 생산자를 따라갈 수 없을 때

- 위 사항에서 선택지 3가지가 존재
    - 메시지 버리기
    - 버퍼링
    - 배압 적용
- 로그 저장 방식은 버퍼링에 속함
- 전통적 메시지 브로커에서는 consumer가 죽으면, 큐를 삭제 하지 않을 경우 불필요한 메시지 누적

#### 오래된 메시지 재생

| 분류 | AMQP, JMS | 로그 기반 메시지 브로커 | 
| -- | -- | -- |
| 메시지 처리 기법 | 작업 처리 후 브로커 내 메시지 제거 | 파일을 읽는 형태 |
| 사이드 이펙트 | 메시지 원복 불가 | consumer offset 이동 |

- 로그 기반 메시지 브로커는 메시징 시스템 내에서 많은 시도 가능

## 데이터베이스와 스트림

- 데이터베이스와 브로커는 다른 범주지만 서로 아이디어를 적용 할 수 있음
- 팔로워가 기록 스트리밍을 복사본을 생성
- 복제 장치 또한 동일한 최종 상태로 끝남

### 시스템 동기화 유지하기

- 각 시스템은 목적에 맞게 최적화된 형태로 재편
- 데이터베이스 전체를 덤프하는 방법이 느리면 **이중 기록** 사용
- 이중 기록의 문제점    
    - DB와 검색 색인 간의 요청 순서가 편차가 생길 경우 두 기록 간의 괴리 발생 가능
    - 한쪽 쓰기가 실패할 가능성 -> 내결함성 문제
- 위 문제를 해결하기 위해서 2PC를 사용하지만 리소스 과소비

### 변경 데이터 캡처

- **변경 데이터 캡처(CDC)** 기술은 모든 데이터 변화를 관찰하여 다른 시스템으로 복제하도록 추출
- 변경 내용을 스트림으로 제공

#### 변경 데이터 캡처의 구현

- 로그 소비자를 **파생 데이터 시스템**이라 할 수 있음
- 데이터베이스 하나를 리더로 하고 나머지는 변경점을 바라보는 팔로워로 할 수 있음
- 데이터테이블의 모든 변화를 관찰하는 트리거를 등록하고 추가하는 방식도 사용할 때가 있음
    - 고장나기 쉽고 오버헤드가 많음 (동기식)
- 비동기 방식으로 동작
    - 느린 소비자가 추가되더라도 레코드 시스템에 미치는 영향이 적음
    - 복지 지연 문제가 전체에 나타남

#### 초기 스냅숏

- 일관성 있는 스냅샷을 사용
- 데이터베이스 스냅샷을 변경 로그의 위치나 오프셋에 대응되어야 함
- CDC 도구에서 일부는 위 기능을 내장

#### 로그 컴팩션

- 로그 양에 대해 추가될 떄마다 스냅샷 생성 방지를 위해 **로그 컴팩션** 이라는 대안 존재
- 저장 엔진은 같은 키의 로그 레코드를 찾아 중복을 제거하고 최근 갱신 내용만 저장(백그라운드 실행)
- 로그 컴팩션 시 실제 데이터를 제거 -> CDC 시스템에서 모든 변경에 기본키가 포함되게 하고 특정 키에 대한 최신 쓰기만 유지
- 메시지 브로커는 이로서 지속성 있는 저장소로도 사용 가능

#### 변경 스트림용 API 지원

- 최근 데이터베이스 변경 스트림을 기본 인터페이스로 지원

| 파이어베이스, 카우치DB | 미티어 | 볼트 DB | 카프카 커넥트 |
| -- | -- | -- | -- |
| 사용 가능한 변경 피드 기반 데이터 동기화 지원 | 몽고DB의 oplog를 사용 |  트랜잭션을 지속적으로 내보내는 출력 스트림 전달 | 광범위 한 변동 데이터 캡처 도구 제공 |

### 이벤트 소싱

- **이벤트 소싱**은 변경 데이터 캡처와 유사하지만 추상화 레벨이 다름
    - 변경 데이터 소싱은 저수준의 복제로그를 파싱
    - 이벤트 소싱은 불변 이벤트를 기반으로 명시적으로 구축 / append만 가능
- 구체적으로 변하지 않는 불변의 이벤트만 저장하고 DB나 어플리케이션 Layer에서 일어나는 실제 파생 효과는 저장하지 않음

#### 이벤트 로그에서 현재 상태 파생하기

- 이벤트 소싱을 사용하는 사용자에게는 결정적 과정을 보여주어야 함
    - 레코드 갱신용 CDC이벤트는 레코드의 가장 새로운 버전을 보여주고 기존 버전은 컴팩션 이후 버림
    - 이벤트 소싱은 상위 수준에서 모델링하기 때문에 이후에 발생한 이벤트가 앞선 이벤트를 덮어쓰기 하지 않음

#### 명령과 이벤트

- **이벤트**와 **명령**을 구분하는 것이 중요
    - 사용자가 최초 요청을 보내었을 때 이는 명령
    - 어플리케이션이 검증 이후 이벤트를 생성 시 이는 **fact**가 되고 이는 거절 불가

### 상태와 스트림 그리고 불변성

- 데이터베이스는 현재 상태는 이벤트의 마지막 결과
- **변경 로그**는 시간에 따라 바뀌는 상태를 의미
- DB는 로그의 부분 집합 캐시
    - 최신 버전만 보유하고 덮어 쓰여진 버전은 삭제

#### 불변 이벤트의 장점

- **원장** 시스템의 경우 거래 정보를 모든 지 담는 형태
- 회계 처리 중 잘못된 처리가 발생한 경우, 이를 정정하는 로그 또한 기록

#### 동일한 이벤트 로그로 여러 가지 뷰 만들기

- 불변 이벤트 로그에서 다양한 형태의 읽기 전용 뷰를 만들 수 있음
- 신규 기능 용으로 최적한 뷰를 만듬으로서 이를 기존 시스템과 양립하도록 처리 할 수 있음
- 이를 **CQRS**라 명명
- 읽기 최적화 된 메뉴의 경우 정규화에 대해서 엄격하지 않음

#### 동시성 제어

- 읽기 뷰의 갱신과 이벤트를 추가하는 작업을 동기식으로 수행하여 비동기로 인한 데이터 차이를 해결
- 해결책
    1. 이벤트 로그와 읽기 뷰를 같은 저장 시스템에 담는 방법 
    2. 이벤트 로그로 현재 상태를 만드는 방법
- 이벤트의 직렬 순서를 파티션 내에서 처리

#### 불변성의 한계

- 불변 히스토리 유지를 위해 커지거나 파편화 문제 발생 가능
- compaction 및 gc 성능 문제 발생 가능
- 사생활 이슈 등으로 인해 아예 삭제가 아니라 기록하지 않았던 것처럼 처리하는 방법 - **적출**
    - 찾기 어렵게 하는 것도 하나의 방법

## 스트림 처리

- 스트림을 처리하는 방법
    1. 이벤트에서 데이터를 추출하여 저장소 시스템에 기록하고, 다른 클라이언트가 시스템에 데이터를 질의
    2. 이벤트를 사용자에게 전달 (이메일 경고, 실시간 대시보드)
    3. 하나 이상의 입력 스트림
- 스트림 처리를 코드 조각을 **연산자** 혹은 **작업**이라 명명

### 스트림 처리와 사용

- 스트림 처리는 모니터링 목적으로 사용하곤 함
    - 카드 결제 사기 감지
    - 공공 기관 거래 시스템
    - 제조 시스템 ㅗㅁ니터링
    - 군사 첩보 시그템

#### 복잡한 이벤트 처리

- CEP는 문자열에서 특정 문자 패턴을 찾는 방식과 유사
- 선언형 질의 언어나 GUI를 사용하기도 함
- CEP는 DB와 반대로 데이터 저장에 대해서 흘러가면서 이벤트 패턴에 매칭되는 이미지 찾음
- 질의에 대해서는 DB는 일시적, CEP는 오랜 기간 저장

#### 스트림 분석

- 스트림 분석은 대량의 이벤트를 집계하고 통계적 분석을 우선 시
    - 특정 유형 이벤트 빈도 측정
    - 특정 기간 이동 평균 계산
    - 시간 간격에 따르 통계 값 비교
- 집계 시간 간격을 **윈도우**라 명명

#### 구체화 뷰 유지하기

- DB 변경에서는 스트림은 파생 데이터의 동기화를 위해 사용
- 데이터 셋에 대한 뷰를 만들어 효율적 질의를 할 수 있게 보조하고 이 데이터가 변경 될 때 마다 뷰 갱신
- 구체화 뷰 생성을 원할 시 임의의 시간 범위 내에 발생한 **모든** 이벤트가 필요

#### 스트림 상에서 검색하기

- 복잡한 기준으로 개별 이벤트 검색 시
    - 스트림검색 : 질의를 먼저 저장하고 문서는 질의를 지나가면서 실행

#### 메시지 전달과 RPC

- 메시지 처리는 RPC의 대안으로 사용할 수 있음
- 메시지와 이벤트 기반이지만 스트림 처리는 아님
    - 액터 프로그램은 동시성을 관리하고 통신 모듈을 분산 실행 <-> 스트림은 데이터 관리 기법
    - 액터 통신은 단기이고 일대일, 이벤트로그는 지속성 다중 구독

| 액터 프로그램 | 스트림 처리 |
| -- | -- |
| 동시성 관리 및 통신 모듈 분산 실행 매커니즘 | 데이터 관리 기법 |
| 단기적이며 일대일 | 지속성 있고 다중 구독 가능 |
| 임의의 방식 통신 가능 | 잘 정리된 스트림 통신에 사용 |

### 시간에 관한 추론

- 특정 시간에 대한 정의는 관리하기가 어려움
- 스트림 처리 프레임워크는 장비 시스템 시계를 사용
    - 이벤트 생성과 처리의 시간 이격 시 문제 발생 예측
- 일괄 처리는 이벤트 내에 내장된 타임스탬프 이용

#### 이벤트 시간 대 처리 시간

- 처리 지연의 이유에는 많은 사유가 존재
- 또한 지연 시 메시지 순서 예측에 대해 문제가 발생 가능
    - 이벤트 순서가 반대 임에도 도착 순서에 따라 처리 방식 다를 수 있음

#### 준비 여부 인식

- 윈도우 종류 이후 도착한 이벤트로 인해 낙오자 발생 가능 이에 대한 처리 프로세스 필요
- 낙오자 이벤트 처리 방법
    - 낙오자 이벤트 무시 -> 비율이 높아지면 알람
    - 수정 값 발행, 이벤트 포함된 윈도우 기준 갱신

#### 어쨌든 어떤 시계를 사용할 것인가?

- 머신과 서버의 시간을 통해 이벤트 발생 시간을 추정하는 법
- 세 가지 스탬프를 로그로 남김
    - 이벤트가 발생한 시각(장치)
    - 서버로 보낸 시간(장치)
    - 서버에서 이벤트를 받은 시간(서버)

#### 윈도우 유형

- 윈도우의 유형
    - 텀블링 윈도우
        - 고정 길이
        - 겹치는 부분 없음
    - 홉핑 윈도우
        - 고정 길이
        - 겹치는 부분 존재
    - 슬라이딩 윈도우
        - 고정 길이
        - 겹치는 부분은 이벤트 따라 상이
    - 세션 윈도우
        - 동적변동 길이
        - 데이터 기반 윈도우

[참고](https://learn.microsoft.com/ko-kr/azure/stream-analytics/stream-analytics-window-functions)

### 스트림 조인

- 일괄 처리 작업과 비슷하지만 새로운 이벤트가 언제든 나타날 수 있음

#### 스트림 스트림 조인(윈도우 조인)

- 모든 이벤트는 세션 ID로 색인 처리
- 한 번의 하나의 활동 이벤트를 대상으로 ID를 찾아 프로필 정보 추가
- 검색, 클릭 이벤트 발생 시 색인에 추가하고 같은 세션 내에 다른 색인 확인 
- 이벤트 매칭 시 검색한 결과를 클릭했다고 말하는 이벤트 방출

#### 스트림 테이블 조인(스트림 강화)

- DB에서 데이터 가져와 이벤트 스트림과 조인
- 네트워크 왕복 없이 스트림 처리자 내부에 데이터베이스 사본 적재
- 사본 용량에 따라 해시 테이블 및 로컬 디스크 적재 가능
- 복사본을 CDC를 통해 최신 값 유지
- 스트림 스트림 조인과 비슷하지만 테이블 변경 로직은 레코드의 새 버전으로 덮어 쓴다

#### 테이블 테이블 조인(구체화 뷰 유지)

- 양쪽 입력 스트림이 모두 DB의 변경 로그
- 결과는 두 테이블 조인의 구체화 뷰 결과 

#### 조인의 시간 의존성

- 하나의 조인 결과를 기반으로 그 상태를 유지
    - 이 상태를 기반으로 질의
- 시간에 따라 변하는 상태를 조인을 할 경우는?
    - 복수 개의 이벤트 순서가 결정적이지 않으면 조인 또한 비 결정적
    - 이런 문제는 **천천히 변하는 자원(SCD)**라 명명
        - 유일한 식별자를 통해 처리
        - 결정적이지만 레코드의 모든 버전이 필요하므로 로그 캠팩션 불가

### 내결함성

- 일괄 처리와는 다르게 스트림은 무한하기 때문에 재시도 불가능
- **exactly-at-once**라는 용어는 결과적으로 한번이라는 뜻

#### 마이크로 일괄 처리와 체크 포인트

- 마이크로 일괄 처리 : 스트림을 작은 블록으로 나누고 소형 일괄 처리와 같이 다루는 방법
    - 처리 속도는 1초 정도
        - 처리 크기가 작을 수록 스케쥴링과 코디네이팅 비용 상승
        - 처리 크기가 클수록 처리 결과를 보내는 지연 시간 상승
- 체크 포인트 : 주기적으로 상태의 롤링 체크 포인트를 생성하고 지속성 있는 저장소에 저장
    - 스트림 연산자에 장애 발생시 가장 최근 체크 포인트에서 재시작
- 위 접근 법으로 충분치 않음

#### 원자적 커밋 재검토

- 장애가 발생했을 때 한 번에 처리 되는 것처럼 보이기 위해 모든 출력과 이벤트 처리의 부수 효과 발생하게 해야함
    - 원자적이거나 동기화

#### 멱등성

- 실패한 태스크의 부분 출력을 버려 한 번만 수행하도록 처리
- 연산이 멱등적이지 않아도 부분 메타데이터로 이를 가능게 할 수 있음
- 모든 메시지는 영속적이고 단조 증가하는 오프셋 존재
- 트리거 메시지의 오프셋을 포함한 다면 갱신 여부 체크가 가능하여 중복 실행 방지 가능

#### 실패 후에 상태 재구축하기

- 원격 데이터 저장소에 상태를 재구축하고 복제
- 