# ch11 스트림 처리

- 일반적인 이벤트 처리는 입력이 완료되어야 출력이 시작
- 일괄 처리 같이 입력 값이 큰 경우 출력 값이 시작 할 수 없음
- 따라서 이를 점진적으로 처리하는 기법을 스트림 처리라 명명

## 이벤트 스트림 전송

- 레코드는 스트림에서는 **이벤트**라고 불리는 형태로 불림
- 이진 형태 혹은 JSON 형태로 input 값을 저장하고 이를 출력
- input에 해당하는 주체를 **producer** / output에 해당하는 주체를 **consumer**로 명명
- 또한 폴링 방식은 비용이 크므로, 이벤트 발생 시 consumer에게 전달하는 **트리거** 형식을 사용

### 메시징 시스템

- 메시징 시스템 상에서 해결 해야하는 두 가지 키워드
    - consumer 속도가 producer이 빠를 경우 - **backpressure(배압현상)**
    - 노드가 죽거나 일시적으로 멈춤 현상이 생길 경우 처리 방법

#### 생산자에서 소비자로 메시지를 직접 전달하기

- 대부분의 메시징 시스템은 직접 전달
    - UDP 멀티캐스트는 신뢰성이 낮은 UDP를 사용하지만 복구가 가능
    - ZeroMQ는 TCP/IP 상에서 브로커 없이 Pub/Sub 모델 구현
    - StatsD, BruBeck는 UDP모델을 사용하여 모니터링
    - 서비스 노출 시 RPC나 HTTP 요청을 보낼 수 있음
- 다만 위의 시스템은 어플리케이션 중 일부가 오프라인이 되거나 네트워크 상에서 패킷이 유실 될 경우 문제가 발생 할 수 있음

#### 메시지 브로커

- producer와 consumer가 중간에 broker에 데이터를 보관하는 형태로 사용 가능
- 소비자는 일반적으로 비동기로 동작
- 위 브로커는 메모리 혹은 디스크로 시스템에 따라 다름

#### 메시지 브로커와 데이터베이스 비교

- 메시지 브로커는 명시적으로 삭제하기 전까지 보관하지만 전달 후 삭제한다는 점에서 DB와 다름
- 브로커는 큐의 크기가 상당히 작음
- 브로커는 토픽의 부분 집합을 구독하는 형태
- 질의 시점의 스냅샷을 기준으로 진행

#### 복수 소비자

- 주요 패턴 두 가지
    - 로드 밸런싱
        - consumer group 상에서 consumer를 임의로 지정
        - 메시지 처리 비용이 비쌈
    - 팬 아웃
        - 모든 consumer에게 전달
- 두 패턴은 동시 사용 가능

#### 확인 응답과 재전송

- 브로커는 컨슈머가 데이터를 받았을 경우 **확인 응답**을 통해 이를 확인
- 다만 데이터 수신 도중 consumer가 중간에 죽을 경우 메시지 수신 과정에서 순서가 지켜지지 않을 수 있음
    - 위 문제는 인과성 있는 로직에서 문제가 발생 가능

### 파티셔닝된 로그

#### 로그를 사용한 메시지 저장소
#### 로그 방식과 전통적인 메시징 방식의 비교
#### 소비자 오프셋
#### 디스크 공간 사용
#### 소비자가 생산자를 따라갈 수 없을 때
#### 오래된 메시지 재생

## 데이터베이스와 스트림

### 시스템 동기화 유지하기
### 변경 데이터 캡처
### 이벤트 소싱
### 상태와 스트림 그리고 불변성

## 스트림 처리

### 스트림 처리와 사용
### 시간에 관한 추론
### 스트림 조인
### 내결함성