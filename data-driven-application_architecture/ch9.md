# ch9 일관성과 합의

- 분산 시스템 상에서는 많은 것들이 잘 못 될 가능성이 존재
- 문제 사항에 대해서 내결함성을 지니는 알고리즘과 프로토콜의 몇 가지 예를 살펴볼 예정
- 모든 노드가 프로세스에 동의하도록 함으로 해결
    - <b>합의</b>

## 일관성 보장

- 대부분의 복제 데이터베이스는 <b>최종적 일관성</b> 이자 <b>수렴</b> 제공
- 최종적 일관성은 시간에 대한 제약 조건이 없기 때문에 문제점이 많음
- 위 문제를 해결하기 위한 다른 일관성 보장 방법 소개
    - <b>선형성</b>과 장점과 단점
    - 분산시스템의 이벤트 순서화 문제
    - 분산트랜잭션을 원자적으로 커밋하는 방법

## 선형성

- 선형성의 기본적인 아이디어는 시스템에 하나의 복사본이 존재하고 그 데이터를 읽음
- 클라이언트는 읽힌 값이 최신값을 읽는다고 생각해야 함 : <b>최신성 보장</b>

### 시스템에 선형성을 부여하는 것은 무엇인가?

- 기본적으로 읽기 연산과 쓰기 연산이 실행 될 때 과거의 값을 발행할 가능성 또한 존재
- 연산의 순서가 진행되면서 새로운 값과 과거의 값이 공존나오는 가능성을 제거 해야 한다
- 따라서 compare-and-set 연산을 추가
- 읽는 시점에 데이터가 쓰기 연산을 그대로 반영하지 않더라도 유효한 순차로 배열되는 지 확인 필요

```
직렬성과 선형성의 차이

직렬성 : 트랜잭션의 격리 속성으로 실제와 순서가 다르더라도 실행되는 것처럼 보여줌

선형성 : 읽기와 쓰기에 대한 최신성 보장 트랜잭션으로 묶는 등의 추가 연산이 없는 경우 쓰기 스큐 등의 문제 방지 불가능
```

### 선형성에 기대기

- 선형성이 중요한 요구 사항이 되는 사례 소개

#### 잠금과 리더 선출

- 모든 노드는 잠금을 소요하는 지 동의해야 함
- 또한 코디네이터 서비스를 사용하기도 함

#### 제약 조건과 유일성 보장

- 유일성 제약 조건
    - 경로와 파일 이름이 동일한 파일 제약
    - 사용자 ID 제약
- 실제 어플리케이션 레벨에서는 사용자에게 양해를 구함으로써 완화 가능

#### 채널 간 타이밍 의존성

- 2가지 메시지 타입이 전달 될 때 두 개의 채널을 통해 사용자에게 도달할 경우 두 가지 채널 사이에 처리 시간으로 인해 경쟁 조건 발생 가능
- 예시 기준 파일 저장소 이미지 vs 메시지 큐

### 선형성 시스템 구현하기

- 구현 방법의 종류
    - 단일 리더 복제
        - 데이터의 주 복사본을 리더가 가지고 다른 팔로우가 보관
        - 리더가 확실히 안다고 가정
    - 합의 알고리즘
        - 스플릿 브레인 형태
    - 다중 리더 복제
        - 일반적으로 비선형적
        - 충돌 쓰기를 만들 수 있음
    - 리더 없는 복제(비선형적)
        - 시계 스큐 때문에 이벤트 실제 순서와 일치하다고 보기 어려움

#### 선형성과 정족수

- 다이나모 스타일에서 사본 간의 쓰기 지연 시간이 제각각인 경우, 선형성을 잃게 됨
- 만약 이를 극복하기 위해서는 읽기 복구를 동기식으로 수행 필요
    - 리악은 수행 X
    - 카산드라는 기다리지만, 동시 쓰기가 다발적으로 일어날 경우 선형성을 잃음

### 선형성의 비용

- 다중 리더 데이터 베이스의 경우 데이터 센터 간 네트워크 중단 현상이 일어날 경우 정상 동작 가능
- 단일 리더 복제의 경우 팔로우에서 데이터 뒤쳐짐 경험 가능
    - 선형 쓰기를 요구할 경우 사용 불가

#### CAP 정리
- 선형성 요구에 따라 가용에 대한 수치가 달라진다
- 네트워크 분단 시 일관성 혹은 가용성을 선택하라는 의미로 해석하는 게 옳다

#### 선형성과 네트워크 지연

- CPU 코어 마저 각자의 메모리 캐시와 저장 버퍼를 가져 선형성을 지니지 않음
- 선형성을 제거하는 가장 큰 이유는 <b>성능</b>
- 현재 장 기준에서는 이 트레이드 오프가 명확함

## 순서화 보장

### 순서화와 인과성

- 순서화과 인과성을 보존하는 데에 도움을 줌
- 인과성이 중요한 예
    - 질문과 답변 사이의 인과적 의존
    - 쓰기의 추월 사태
    - 트랜잭션 사이의 인과적 의존성으로 인한 쓰기 스큐 검출
- 시스템에 인과에 의한 순서를 지킬 경우 <b>인과적 일관성</b>이라 지칭

#### 인과적 순서는 전체 순서는 아니다

- 전체 일어난 순서가 지켜지는 것이 아닌 인과적 연관 관계가 있는 것에 대해 순서가 지켜지는 것
    - 선형성 : 전체 순서를 지키는 것
    - 인과성 : 인과가 있는 것에 해당하는 두 이벤트 간에 순서가 지켜져야 함

#### 선형성은 인과적 일관성 보다 강하다

- 선형성은 인과성을 내포
- 실제로 중요한 것은 인과적 일관성

#### 인과적 의존성 담기

- 연산 간의 앞뒤 순서 파악 필요
- 데이터베이스에서 어떤 버전을 읽었는 지 확인 필요

### 일련번호 순서화

- 일련 번호 혹은 타임스탬프를 사용하여 이벤트 순서를 정함 혹은 논리적 순서
- 위 처리를 통해 전체 순서에 대한 논리적 순서 파악 가능

#### 비인과적 일련번호 생성기

- 단일 리더가 없는 경우 사용하는 다양한 방법
    - 각 노드에서 쓰는 독립적인 일련 번호
    - 타임스탬프 사용
    - 일련 번호 블록 할당
- 위 방법들은 인과성에 일관적이지 못함

#### 램포트 타임 스탬프

- 가장 먼저 타임스탬프로 비교 -> 그 이후 노드 ID로 비교
- 카운터가 더 최대값일 경우 그 카운터를 최대값으로 정의
- 버전 벡터보다 더 크기가 작음

#### 타임 스탬프 순서화로는 불충분

- 이 방법은 사후에 결정할 경우에만 효과적
- 따라서 전체 순서 브로드캐스트 사용 필요

### 전체 순서 브로드캐스트

- CPU에서 실행된 순서로 파악
- 두 가지 안전 속성 만족 필요
    - 신뢰성 있는 전달 : 메시지 미손실
    - 전체 순서가 전달된 전달 : 모든 노드에 같은 순서로 전달

#### 전체 순서 브로드캐스트 사용하기

- 데이터베이스에 쓰기를 나타내고 같은 순서로 모든 노드에서 처리 -> 상태 기계 복제
- 메시지가 전달되는 시점에 순서가 고정

#### 전체 순서 브로드캐스트를 사용해 선형성 구현

- 전체 순서 브로드캐스트에서 compare-and-set 연산을 다음과 같이 구현
    1. 메시지에 로그를 추가하여 사용자를 명시
    2. 로그를 읽고, 추가한 메시지 회신 대기
    3. 원하는 사용자명을 점유하려고 하는 메시지가 있는지 확인 - 사용자가 다를 경우 abort
- 선형적 쓰기만 적용한 상태 읽기를 반영할 경우 아래의 선택지 추가 필요
    - 로그를 통한 순차 읽기
    - 모든 항목 전달 대기 후 읽기 수행
    - 쓰기를 실행할 때 동기식 실행

#### 선형적 저장소를 사용해 전체 순서 브로드 캐스트 구현

- 모든 메시지에 대한 increment-and-get 연산 수행 후 일련번호를 메시지에 추가
- 문제는 노드에 장애 날 때 값을 복구해야할 경우

## 분산 트랜잭션과 합의

- 여러 노드들이 특정한 결정에 대해 동의하게 만드는 것
- 노드가 동의하는 것이 중요한 상황 종류
    - 리더 선출
    - 원자적 커밋
        - 모든 노드에서 트랜잭션 결과에 동의하게 만드는 만들어야 함

```
합의 불가능성

- 특정 노드가 죽을 가능성이 있는 경우 항상 합의를 이루지 못한다는 이론
- 알고리즘이 타임아웃을 쓰는 것이 허용되거나 죽은 것으로 의심되는 것을 식별하는 다른 방법이 있으면 해결 가능
```

### 원자적 커밋과 2단계 커밋(2PC)

- 트랜잭션의 결과는 커밋 성공 or 어보트
- 보조 색인과 주 데이터는 일관성을 유지해야 함
- 위 내용을 원자적 커밋이라 명명

#### 단일 노드에서 분산 원자적 커밋으로

- 단일 DB에서 원자성은 저장소 엔진 내에 구현
- 디스크에 기록하는 시점에 커밋 레코드 쓰기를 마침
- 분산 트랜잭션 환경에서는 손실 위험이나 제약 조건 위반 때문에 확실하지 않을 수 있음

#### 2단계 커밋 소개

- 2PC 커밋은 모든 노드에 커밋 Or 어보트를 보장하는 알고리즘
    - XA 트랜잭션의 형태나 SOAP 에서도 사용 가능
- <b>코디네이터 (트랜잭션 관리자)</b>를 사용
- 2PC 커밋 플로우
    1. 어플리케이션이 커밋할 준비가 될 경우 코디네이터가 1단계 시작
        - 각 노드에 준비 요청을 보내서 커밋 확인
    2. 코디네이터가 응답 추적
        - 모두 '네'일 경우 커밋 실행
        - 한 명이라도 아니일 경우 어보트 수행

#### 약속에 관한 시스템

- 2단계 커밋과 1단계 커밋은 세부 내용이 다름
- 세부 과정 분석
    1. 트랜잭션 ID 요청
    2. 단일 노드에서 에서 유일한 트랜잭션 ID를 붙이고 문제가 생길 경우 어보트
    3. 어보트가 되지 않는 다면, 코디네이터 전역 노드에 ID로 태깅된 준비 요청 전달
    4. 참여자가 모두 네라고 응답할 경우 커밋 약속을 회신하고 대기
    5. 코디네이터가 이 결정에 대해 최종 결정을 내리고 이를 <b>커밋 포인트</b>라 명명
    6. 코디네이터 결정이 쓰여질 경우 이 결정에 따라 모든 노드가 무조건 수행 하도록 진행
- 커밋 포인트의 여부의 차이가 절대적

#### 코디네이터 장애

- 코디네이터가 장애가 날 경우 이 때 진행되던 트랜잭션을 의심스럽다고 명명
- 2PC에서 코디네이터가 장애가 날 경우 복구를 대기 해야 함
- 단일 노드에 커밋 레코드를 저장하고 복구 될 때 코디네이터에서 로그를 읽어 트랜잭션 상태를 결정

#### 단계 커밋

- 2PC의 대안으로 3단계 커밋 알고리즘가 존재
- 완벽한 장애 감지를 위한 신뢰성 있는 메커니즘 필요
- 노드가 다 죽지 않아도 네트워크 이슈로 인해 타임아웃 가능

### 현실의 분산 트랜잭션

- 특정 트랜잭션 구현은 성능 손해 동반 (ex. mySQL 분산 트랜잭션은 10배 이상 느려진다고 보고)
- 분산 트랜잭션의 구체적인 종류
    - 데이터베이스 내부 분산 트랜잭션
    - 이종 분산 트랜잭션 / 후자가 더 어려움

#### 정확히 한 번 메시지 처리

- exactly once 처리를 위한 프로토콜이 있어야 이종 분산 트랜잭션 처리 가능

#### XA 트랜잭션

- 트랜잭션 코디네이터는 XA API를 구현
- 준비 요청을 보내고 응답을 수집 후에 로컬 디스크에 있는 로그 사용
- 코디네이터 죽을 경우 데이터베이스 드라이버의 XA 콜백을 통해 커밋이나 어보트 하라고 요청

#### 의심스러운 상태에서 잠금을 유지하는 문제

- 의심스러운 상태에서는 읽기 로우 및 공유 잠금을 얻으므로 시스템의 많은 부분을 사용하기 어려움

#### 코디네이터 장애에서 복구하기

- 코디네이터가 재시작 할 경우 의심스러운 트랜잭션 해소 필요
- 2PC에서는 의심스러운 트랜잭션 중 고아가 된 트랜잭션이 생길 수 있음
- 위 트랜잭션에 대해 처리하는 방법에 대한 <b>경험적 결정</b>이 필요
    - 경험적 결정은 원자성을 깰 수 있음

#### 분산 트랜잭션의 제약

- 코디네이터가 복제 되지 않으면 SPOF가 될 수 있음 / 다만 여러 코디네이터는 고가영성을 미제공
- 코디네이터가 서버의 일부가 될 경우 상태 비저장 모드로 개발
- XA는 여러 시스템에 내에서 충돌을 감지하는 프로토콜이 필요하기 때문에 최소의 공통 분모가 되어야 함

    ### 내결함성을 지닌 합의

- 합의 알고리즘은 아래를 만족해야 함
    - 균일한 동의 : 모두 같은 결정을 진행
    - 무결성 : 하나의 노드에서 한 개의 결정
    - 유효성 : 노드 중 하나에서 제안이 와야 함
    - 종료 : 죽지 않는 노드는 결정을 함
- 노드가 절반 이상 살아있다고 가정
- 합의 알고리즘은 비잔틴 결함이 없다고 가정

#### 합의 알고리즘과 전체 순서 브로드 캐스트

- 합의 알고리즘의 특징
    - 값의 순차열을 결정해서 전체 순서 브로드 캐스트 알고리즘을 만듬
    - 전체 브로드 케스트는 합의를 여러번 반복 하는 것과 동일
- 뷰스탬프 복제, 라프트, 잽은 전체 브로드 캐스트 알고리즘을 직접 구현

#### 단일 리더 복제와 합의

- 리더를 선출하는 방에 대한 문제 존재

#### 에포크 번호 붙이기와 정족수

- 리더가 죽었을 때 에포크 번호를 비교하여 더 높은 번호가 승리
- 정족수로부터 투표를 받아야 함으로 이를 대기
- 이를 위한 두 번의 투표 필요
    - 리더 선출
    - 리더의 제안 투표
- 두 번째 투표에 참가하기 위해서는 전자의 투표에도 참여해야 함
- 과반수 이상의 정족수를 받아야 함를 받는 것이 2PC와의 차이점

#### 합의의 제약

- 제안에 투표하는 과정은 동기식 복제지만 현실 DB는 비동기 복제 허용
- 대부분의 합의 알고리즘은 투표하는 노드가 고정되어 있다 가정
- 합의 알고리즘은 네트워크 이슈에 취약

### 멤버십과 코디네이션 서비스

- 주키퍼나 Etcd는 작은 양의 데이터를 보관하도록 설계
- 또한 아래 기능 집합 구현
    - 선형성 원자적 연산
        - compare and set으로 잠금 구현
    - 연산의 전체 순서화
        - 펜싱 토큰으로 단조 증가하는 순서에 트랜잭션 ID와 버전 번호를 할당하여 제공
    - 장애 감지
        - 하트비트를 교환하여 노드 생존 확인
    - 변경 알림
        - 변경이 생일 경우 알림을 구독하여 확인
- 실제 합의는 선형성 원자적 연산만 필요

#### 작업을 노드에 할당하기

- 모든 노드의 과반수를 집계하는 것은 비효율적
- 고정된 노드 수에서 실행되고, 과반수 투표를 수행하면서, 많아질 수 있는 클라이언트 지원

#### 서비스 찾기

- 서비스 찾기는 합의가 분명하게 사용되는 지 알 필요는 없음
- 리더 선출은 합의가 필요

#### 멤버십 서비스

- 어떤 노드가 활성화 되어 있는 멤버인지 결정
- 현재 멤버들 중 번호가 가장 낮은 것을 선택하는 방식