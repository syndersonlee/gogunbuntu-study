# ch9 일관성과 합의

- 분산 시스템 상에서는 많은 것들이 잘 못 될 가능성이 존재
- 문제 사항에 대해서 내결함성을 지니는 알고리즘과 프로토콜의 몇 가지 예를 살펴볼 예정
- 모든 노드가 프로세스에 동의하도록 함으로 해결
    - <b>합의</b>

## 일관성 보장

- 대부분의 복제 데이터베이스는 <b>최종적 일관성</b> 이자 <b>수렴</b> 제공
- 최종적 일관성은 시간에 대한 제약 조건이 없기 때문에 문제점이 많음
- 위 문제를 해결하기 위한 다른 일관성 보장 방법 소개
    - <b>선형성</b>과 장점과 단점
    - 분산시스템의 이벤트 순서화 문제
    - 분산트랜잭션을 원자적으로 커밋하는 방법

## 선형성

- 선형성의 기본적인 아이디어는 시스템에 하나의 복사본이 존재하고 그 데이터를 읽음
- 클라이언트는 읽힌 값이 최신값을 읽는다고 생각해야 함 : <b>최신성 보장</b>

### 시스템에 선형성을 부여하는 것은 무엇인가?

- 기본적으로 읽기 연산과 쓰기 연산이 실행 될 때 과거의 값을 발행할 가능성 또한 존재
- 연산의 순서가 진행되면서 새로운 값과 과거의 값이 공존나오는 가능성을 제거 해야 한다
- 따라서 compare-and-set 연산을 추가
- 읽는 시점에 데이터가 쓰기 연산을 그대로 반영하지 않더라도 유효한 순차로 배열되는 지 확인 필요

```
직렬성과 선형성의 차이

직렬성 : 트랜잭션의 격리 속성으로 실제와 순서가 다르더라도 실행되는 것처럼 보여줌

선형성 : 읽기와 쓰기에 대한 최신성 보장 트랜잭션으로 묶는 등의 추가 연산이 없는 경우 쓰기 스큐 등의 문제 방지 불가능
```

### 선형성에 기대기

- 선형성이 중요한 요구 사항이 되는 사례 소개

#### 잠금과 리더 선출

- 모든 노드는 잠금을 소요하는 지 동의해야 함
- 또한 코디네이터 서비스를 사용하기도 함

#### 제약 조건과 유일성 보장

- 유일성 제약 조건
    - 경로와 파일 이름이 동일한 파일 제약
    - 사용자 ID 제약
- 실제 어플리케이션 레벨에서는 사용자에게 양해를 구함으로써 완화 가능

#### 채널 간 타이밍 의존성

- 2가지 메시지 타입이 전달 될 때 두 개의 채널을 통해 사용자에게 도달할 경우 두 가지 채널 사이에 처리 시간으로 인해 경쟁 조건 발생 가능
- 예시 기준 파일 저장소 이미지 vs 메시지 큐

### 선형성 시스템 구현하기

- 구현 방법의 종류
    - 단일 리더 복제
        - 데이터의 주 복사본을 리더가 가지고 다른 팔로우가 보관
        - 리더가 확실히 안다고 가정
    - 합의 알고리즘
        - 스플릿 브레인 형태
    - 다중 리더 복제
        - 일반적으로 비선형적
        - 충돌 쓰기를 만들 수 있음
    - 리더 없는 복제(비선형적)
        - 시계 스큐 때문에 이벤트 실제 순서와 일치하다고 보기 어려움

#### 선형성과 정족수

- 다이나모 스타일에서 사본 간의 쓰기 지연 시간이 제각각인 경우, 선형성을 잃게 됨
- 만약 이를 극복하기 위해서는 읽기 복구를 동기식으로 수행 필요
    - 리악은 수행 X
    - 카산드라는 기다리지만, 동시 쓰기가 다발적으로 일어날 경우 선형성을 잃음

### 선형성의 비용

- 다중 리더 데이터 베이스의 경우 데이터 센터 간 네트워크 중단 현상이 일어날 경우 정상 동작 가능
- 단일 리더 복제의 경우 팔로우에서 데이터 뒤쳐짐 경험 가능
    - 선형 쓰기를 요구할 경우 사용 불가

#### CAP 정리
- 선형성 요구에 따라 가용에 대한 수치가 달라진다
- 네트워크 분단 시 일관성 혹은 가용성을 선택하라는 의미로 해석하는 게 옳다

#### 선형성과 네트워크 지연

- CPU 코어 마저 각자의 메모리 캐시와 저장 버퍼를 가져 선형성을 지니지 않음
- 선형성을 제거하는 가장 큰 이유는 <b>성능</b>
- 현재 장 기준에서는 이 트레이드 오프가 명확함

## 순서화 보장

### 순서화와 인과성

- 순서화과 인과성을 보존하는 데에 도움을 줌
- 인과성이 중요한 예
    - 질문과 답변 사이의 인과적 의존
    - 쓰기의 추월 사태
    - 트랜잭션 사이의 인과적 의존성으로 인한 쓰기 스큐 검출
- 시스템에 인과에 의한 순서를 지킬 경우 <b>인과적 일관성</b>이라 지칭

#### 인과적 순서는 전체 순서는 아니다

- 전체 일어난 순서가 지켜지는 것이 아닌 인과적 연관 관계가 있는 것에 대해 순서가 지켜지는 것
    - 선형성 : 전체 순서를 지키는 것
    - 인과성 : 인과가 있는 것에 해당하는 두 이벤트 간에 순서가 지켜져야 함

#### 선형성은 인과적 일관성 보다 강하다

- 선형성은 인과성을 내포
- 실제로 중요한 것은 인과적 일관성

#### 인과적 의존성 담기

- 연산 간의 앞뒤 순서 파악 필요
- 데이터베이스에서 어떤 버전을 읽었는 지 확인 필요

### 일련번호 순서화

- 일련 번호 혹은 타임스탬프를 사용하여 이벤트 순서를 정함 혹은 논리적 순서
- 위 처리를 통해 전체 순서에 대한 논리적 순서 파악 가능

#### 비인과적 일련번호 생성기

- 단일 리더가 없는 경우 사용하는 다양한 방법
    - 각 노드에서 쓰는 독립적인 일련 번호
    - 타임스탬프 사용
    - 일련 번호 블록 할당
- 위 방법들은 인과성에 일관적이지 못함

#### 램포트 타임 스탬프

- 가장 먼저 타임스탬프로 비교 -> 그 이후 노드 ID로 비교
- 카운터가 더 최대값일 경우 그 카운터를 최대값으로 정의
- 버전 벡터보다 더 크기가 작음

#### 타임 스탬프 순서화로는 불충분

- 이 방법은 사후에 결정할 경우에만 효과적
- 따라서 전체 순서 브로드캐스트 사용 필요

### 전체 순서 브로드캐스트

- CPU에서 실행된 순서로 파악
- 두 가지 안전 속성 만족 필요
    - 신뢰성 있는 전달 : 메시지 미손실
    - 전체 순서가 전달된 전달 : 모든 노드에 같은 순서로 전달

#### 전체 순서 브로드캐스트 사용하기

- 데이터베이스에 쓰기를 나타내고 같은 순서로 모든 노드에서 처리 -> 상태 기계 복제
- 메시지가 전달되는 시점에 순서가 고정

#### 전체 순서 브로드캐스트를 사용해 선형성 구현

- 전체 순서 브로드캐스트에서 compare-and-set 연산을 다음과 같이 구현
    1. 메시지에 로그를 추가하여 사용자를 명시
    2. 로그를 읽고, 추가한 메시지 회신 대기
    3. 원하는 사용자명을 점유하려고 하는 메시지가 있는지 확인 - 사용자가 다를 경우 abort
- 선형적 쓰기만 적용한 상태 읽기를 반영할 경우 아래의 선택지 추가 필요
    - 로그를 통한 순차 읽기
    - 모든 항목 전달 대기 후 읽기 수행
    - 쓰기를 실행할 때 동기식 실행

#### 선형적 저장소를 사용해 전체 순서 브로드 캐스트 구현

- 모든 메시지에 대한 increment-and-get 연산 수행 후 일련번호를 메시지에 추가
- 문제는 노드에 장애 날 때 값을 복구해야할 경우
- 

## 분산 트랜잭션과 합의

### 원자적 커밋과 2단계 커밋(2PC)
### 현실의 분산 트랜잭션
### 내결함성을 지닌 합의
### 멤버십과 코디네이션 서비스
