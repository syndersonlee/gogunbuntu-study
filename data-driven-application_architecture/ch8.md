# ch8 분산 시스템의 골칫거리

- 엔지니어로서 각종 결함이 생기더라도 제 역할을 수행하도록 시스템 구축 필요성이 있음
- 이에 대한 해결 방법 확인 필요

## 결함과 부분 장애

- 일반적인 소프트웨어는 소프트웨어 연산 전체에 대해 Atomic 하도록 구현
- 단일 하드웨어 안에서는 이에 따라 전체 Failover 혹은 전체 성공으로 분류
- 다만 네트워크로 연결된 소프트웨어는 상황이 다름
- 이에 따른 부분적으로 특정 시스템만 동작하는 상황
    - <b>부분 장애 (partial failure)</b> 라고 명명
- 부분 장애는 비결정적 성격을 지님
    - 성공 여부 확인 불가

### 클라우드 컴퓨팅과 슈퍼 컴퓨팅

| 고성능 컴퓨팅(HPC) | 전통적인 기업형 데이터 센터 | 클라우드 컴퓨팅 |

- 고성능 컴퓨팅
    - 일기예보 같은 계산 비용이 높은 과학 계산 작업에 사용하기 위해 CPU가 높음
- 클라우드 컴퓨팅
    - Multi Tenant Data Center, IP 네트워크 등, elastic 관련 특징과 높은 컴퓨터
- 기업형 데이터 센터는 위 두 가지 특징 중간 지점을 가짐

- 슈퍼 컴퓨터의 장애 처리
    - 노드 하나 장애 발생 시 체크포인트로 저장되어 있는 부분부터 전체 장애 처리 후 재시작하도록 처리
- 인터넷 서비스는 위와 결이 다른 형태
    - 낮은 지연 시간을 가져야 하며, 전체 서비스 중단은 비허용
    - 상용 장비를 사용하며, Failover 가능성이 슈퍼컴퓨터보다 상대적으로 높음
    - IP, 이더넷 기반 통신
    - 시스템이 비대해 질 수록 결함 가능성 상승
    - 인터넷을 사용할 경우 속도가 느리고 신뢰성 하락
- 소프트웨어는 결함이 필수적으로 발생한다 가정하고 이를 대비하기 위한 설계 필요

#### 신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템 구축하기

- 하위 계층의 오류를 상위 계층의 요소를 사용해 신뢰성을 높히는 방법
    - OSI 3계층 Network 계층(IP)의 신뢰성을 위해 4계층 Transport(TCP)를 사용하여 손실된 패킷을 재전송하고 중복된 것을 제거
    - 네트워크 계층의 오류를 어플리케이션 레이어에서 정확히 전송하도록 처리하는 것

## 신뢰성 없는 네트워크

- 분산 시스템은 주로 비공유 시스템으로 구성
- 비공유 시스템은 네트워크를 통해 통신
    - 상대적으로 저렴
    - 여러 데이터 센터에 중복 배치하여 높은 신뢰성 보장
- 대부분 <b>비동기 패킷 네트워크</b>로 구성
- 데이터 전달 과정에서 실패 가능성 존재
    1. 데이터 손실
    2. 데이터 지연
    3. 수신 노드 장애
    4. 수신 노드 지연 및 응답 지연
    5. 네트워크 과정 손실
    6. 하드웨어 과부하로 인한 응답 지연
- 위 문제를 해결하기 위한 유일한 인식 방법 = <b>타임아웃</b>

### 현실의 네트워크 결함

- 네트워크 결함은 언제든지 발생 가능하고 이를 소프트웨어가 처리할 필요성 존재
- 해결이 어려울 경우 오류 메시지 전달 후 재시도 처리하도록 할 수도 있음

### 결함 감지

- 시스템은 결함 노드 감지가 필요
    - 로드밸런서는 죽은 노드에 데이터 전송을 멈춰야 함
    - 팔로워 중 하나가 리더로 승격해야 함

- 노드 감지에 대한 피드백 종류
    - 수신 대기하는 프로세스의 존재 유무로 판단
    - 운영체제가 인지할 경우 다른 노드로 역할을 넘겨줌
    - 질의를 통해 하드웨어 장애 파악
    - IP 주소가 다다를 수 없는 경우 제한 적용
- 일반적으로 ACK를 통해 성공 확신, 타임아웃을 통해 노드가 죽었다고 인지

### 타임아웃과 기약 없는 지연

- 타임아웃이 길 경우 죽었다고 기다리는 시간이 길어짐
- 짧을 경우 느려짐을 죽었다고 판단할 경우가 생김 -> 중복 실행 / 과부화 악화의 원인
- 결론 : 답은 없음
- 일반적으로 d : 전송 시간 / r을 요청 처리 시간이라고 했을 때 2d + r을 타임아웃 시간으로 잡는 것이 합리적

#### 네트워크 혼잡과 큐 대기

- 네트워크의 지연 변동성은 큐 대기의 가능성이 높음
    - 네트워크가 잘 동작하더라도 입력과 출력 상의 슬롯이 없을 경우 기다려야 하는 경우가 많음
    - CPU 코어를 사용하는 동안 바쁠 경우 운영체제 큐에 넣어놓음
    - 가상 장비 모니터는 데이터를 큐에 넣어 버퍼링
    - TCP는 송신율을 제한 <b>(흐름 제어, 배압)</b>
- 공개 클라우드나 멀티 tenant 데이터 센터에서는 자원을 공유 함으로 지연 변동이 클 수 있음
- 이 때는 타임 아웃을 유동적으로 변동성을 측정하고 자동으로 timeout 값을 조정토록 진행

##### TCP vs UDP

- 지연된 데이터에 대한 유실 가능성을 무시할 경우 UDP 사용
- 동영상이나 통화 등

### 동기 네트워크 대 비동기 네트워크

- 패킷 최대 전송량을 조정하고 고정된 비율로 보내서 동기식으로 처리 - <b>제한 있는 지연</b>

#### 네트워크 지연을 예상가능 하도록 조정

| | TCP 회선 | 전화 회선 |
| -- | -- | -- |
| 최적화 | 순간적으로 몰리는 트래픽에 최적화(요구 사항 없음) | 초당 비트 개수가 고정 |
| 유동성 | 네트워크 용량에 맞춰 데이터 전송율 동적 조정 가능 | 고정되어 있기 때문에 네트워크 용량 낭비 및 전송이 느려짐 |

- 하이브리드 네트워크
    - 회선 교환과 패킷 교환 모두 지원
    - 링크 계층에서 종단 흐름 제어 구현 지연의 영향을 받을 수 있음
    - 서비스 품질 보장 불가

## 신뢰성 없는 시계

- timeout, response time, qps, 체류 시간, posting time, alarm, expired time, timestamp
- 위 수치들 모두 시계에 의존하는 수치
- 개별 장비의 시간 + 네트워크 시간 비교를 통해 시간 조정 할 수 있음

### 단조 시계 대 일 기준 시계

- 두 가지 시계 종류 종재
    - 일 기준 시계
    - 단조 시계

#### 일 기준 세계

- 우리가 일반적으로 보는 시간
- 로컬 시계가 앞설 경우 강제로 뒤로 이동할 수도 있음

#### 단조 시계

- Linux의 clock_gettime / System.nanoTime()
- 특정 시점의 시간과 어느 정도 시간이 흐른 시점의 데이터를 확인하여 차이를 더함
- 시간이 맞지 않을 경우 속도 조절이 가능
- 시간 점프는 불가능

### 시계 동기화와 정확도

- 일 기준 시계 또한 신뢰성이 높지 않음
    - 장비 온도에 따라 변동 가능
    - 너무 많은 차이가 날 경우 강제 리셋 처리 가능
    - 방화벽 이슈로 인한 차이 발생
    - 네트워크 지연으로 인한 차이
    - NTP 서버 자체의 이상
    - 윤초 이슈
    - 가상 장비를 사용 시 일시적으로 CPU 멈춤 현상 발생
- GPS 수신기, 정밀 시간 프로토콜 등을 사용하여 최대한 정밀한 시계 유지
- 위 방법 또한 문제가 생길 가능성 높음

### 동기화된 시계에 의존하기

- 하나의 시계에서 문제가 발생 시 에러 발견이 어려움으로 모든 장비 사이의 시계 차이를 측정해야 함

### 이벤트 순서화용 타임스탬프

- 분산 환경에서 데이터 적재 시에 타임스탬프가 다를 경우 최종 쓰기 원칙을 어기고 이전 쓰기가 덮어 쓸 가능성 존재
- 이를 처리하기 위해 <b>논리적 수정</b>을 통해 이벤트의 상대적 순서만 측정

#### 시계 읽기는 신뢰 구간이 있다

- 현재 시간을 기준으로 몇 밀리 초에 대한 신뢰 구간 존재
- 구글 트루타임 API는 이를 확인하여 회신

#### 전역 스냅샷용 동기화된 시계

- 스패너는 데이터 센터에 걸쳐 스냅숏 격리를 구현
- 스패너는 커밋 이전에 의도적으로 신뢰 구간의 길이를 대기
- 7밀리 내로 동기화 되게 처리

### 프로세스 중단

- 리더인지 확인하고 이를 통한 안전한 쓰기 유지 방법
    - <b>임차권</b> 획득
- 피해야 할 문제점
    1. 동기화 된 시계에 의존하는 것
    2. 프로그램 실행 시 중단 현상 발생
        - Stop-The-World
        - 가상 장비 suspend 현상
        - 사용자 의도에 의한 suspend
        - Thread 및 HyperVisor Switching
        - I/O 연산 대기에 의한 suspend
        - Memory 접근 시 Disk 페이징

- 위 경우 발생 <b>선점</b> 을 통해 잠시 후 재개 처리
- 다만 분산 시스템에서는 실행이 멈출 가능성이 있고 이를 고려해야 함

#### 응답 시간 보장
- 시스템에게 응답을 요구하는 데드라인을 주고 이를 응답 하지 못할 경우 장애 유발 가능한 시스템
    - <b>엄격한 실시간 시스템</b>
- CPU 시간을 명시적으로 할당 받을 수 있도록 스케줄링 해주는 시스템
    - <b>실시간 운영체제</b> 필요
- 동적 메모리 할당을 제한 혹은 금지

#### GC 영향 제한

1. GC 중단 시 계획적으로 중단하는 것으로 간주하여 다른 노드에게 할당
2. 주기적으로 프로세스를 재시작

- 위 방법으로 Response Time 상위 백분위를 감소

## 지식, 진실, 그리고 거짓말

- 분산 환경에서는 많은 것이 불확실 하기 때문에 최소한의 기반 신뢰 동작에 대한 조건을 알아야 함
- 예외 상황에서 보장되는 알고리즘 살펴볼 예정

### 진실은 다수결로 결정된다

- 분산 시스템 상에서 하나의 노드의 결과는 신뢰성이 떨어짐
- 따라서 여러 분산 알고리즘에 대해 <b>정족수</b>를 통해 노드 투표를 통해 결정

#### 리더와 잠금

- 시스템의 하나의 처리만 필요할 경우
    - 스플릿 브레인 케이스
    - 동시 쓰기 방지
    - 사용자를 유일하게 식별 하는 경우
- 위 케이스 처리 시 하나의 노드에서 자신을 리더라고 믿을 경우 시스템 전체에 오류가 발생할 수 있음

#### 펜싱 토큰

- 위 문제를 해결하기 위한 방법으로 서비스 잠금이나 임차권 승인 시에 펜싱 토큰을 반환
- 코디네이터 프로그램을 통해 오래된 토큰 사용 거부

### 비잔틴 결함

- 가짜 펜싱 토큰을 포함하여 전달하는 문제
- 특정 환경에서는 이를 방지하는 내결함성을 지님
    - 항공 우주 산업 환경에서 특정 노드가 방사선에 오염될 수도 있음
    - 의도적으로 속이려고 하는 경우 블록체인 피어 투 피어
- 비잔틴 내결함 처리는 피어투피어 네트워크에 방지를 하는 것이 적합

### 시스템 모델과 현실

- 시스템 모델의 종류

1. 동기식 모델
    - 네트워크 지연, 시계 오차 등에 제한이 있음
    - 비현실적 모델
2. 부분 동기식 모델
    - 대부분의 시간에는 동기식 처럼 동작
    - 때때로 지연 문제가 발생
3. 비동기식 모델
    - 시계를 사용하지 않늠 ㅗ델
    - 제한적인 용도

노드용 시스템 모델 3가지

1. 죽으면 중단 하는 결함
2. 죽으면 복구하는 결함
3. 비잔틴 결함

### 알고리즘 정확성

- 알고리즘 속성
    - 유일성 : 같은 값을 반환하지 않음
    - 단조 일련번호 : 요청 순서에 따라 순서가 보장
    - 가용성 : 펜싱 토큰을 요청 후 죽지 않은 노드는 반드시 응답을 받음

#### 안정성과 활동성

- 안정성
    - 유일성
    - 단조 일련 번호
- 활동성
    - 가용성 속성
- 안정성은 일반적으로 항상 만족되기를 요구
- 활동성 속성을 경고를 허용

#### 시스템 모델을 현실 세계에 대입

- 이론적인 정족수나 비잔틴 시스템 상에서 일어날 만한 일을 예측하는 것이 완벽하지는 않아도 쓸모는 있음
- 이론적 분석과 실질 경험을 통해 잘 대처하자...(알잘딱깔센을 270줄 넘게 설명하는 망할 책)