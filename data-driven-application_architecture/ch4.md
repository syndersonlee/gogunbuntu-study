# 4장 부호화와 발전

- 대부분의 경우 기능 변경 = 데이터의 변경

데이터의 변경에 대처하는 데이터 모델의 방법?

- 관계형 데이터베이스의 경우 스키마가 변경
- 읽기 스키마 데이터베이스는 강요 X

대규모 업데이트에 대처하는 코드 변경 방법

- 서버 측 어플리케이션의 경우 몇 개의 노드에 새 버전을 배포하고 이후 나머지를 배포하는 Rolling 배포를 사용
- 클라이언트는 사용자에 의해 좌우

변경 시 중요하게 유지해야하는 점

- 하위 호환성
- 상위 호환성

## 데이터 부호화 형식

- 프로그램은 일반적으로 두 개 이상의 데이터 형태를 사용해 표현
- 포인터 및 바이트 열은 메모리에서 사용하는 데이터 구조와 달라 다른 프로세스에서 이해가 불가능
- In-Memory -> 바이트 열의 변환을 직렬화, 마샬링이라고 지칭 / 반대는 파싱, 역직렬화, 언마샬링

### 언어별 형식

프로그래밍 언어에 내장되어 있는 직렬화 문법의 어려운 점이란?

- 부호화를 통해 저장하고 전송할 경우 현재 프로그래밍 언어로 전송해하고 다른 언어와 통합에 방해
- 복호화 과정에서 임의의 클래스를 인스턴스화 가능해야 하며, 이는 공격자가 원격으로 임의의 코드를 실행할 수 있음
- 버전 관리 과정에서 상하위 호환성이 등한 시
- 효율성이 떨어지는 점

### JSON과 XML, 이진 변형

- JSON, XML, CSV는 텍스트 형식 및 사람이 읽을 수 있음

피상적인 문법 이외에 가지고 있는 미묘한 문제

- XML, CSV는 수와 숫자 문자열 구분이 어려움 / JSON은 문자열과 수를 구분 그러나 부동소수점 수 및 정밀도 미지정
- 큰 수를 다룰 때 JSON에서 문제가 발생
- JSON과 XML은 유니코드는 잘 지원 그러나 이진 문자열은 미지원하여 Base64를 사용하는데 이 때 데이터 크게 33% 증가
- XML의 스키마는 꽤 널리 사용, JSON 기반 도구는 스키마를 미강제 하기 때문에 부호화 시에 하드코딩 해야한느 가능성 존재

위와 같은 문제들이 있음에도 다양한 용도로 사용하기 충분

#### 이진 부호화

- JSON은 XML보다 덜 장황하지만 이진 부호보다 훨씬 많은 공간 사용
- 특정 JSON 형태는 모든 객체의 필드 이름을 포함 해야함

### 스리프트와 프로토콜 버퍼

- 스리프트와 프로토콜 버퍼는 같은 원리를 기반으로 한 이진 부호화 라이브러리 
- 부호화할 데이터를 위한 스키마 필요
- 스키마의 레코드를 부호화하고 복호화할 수 있음

### 아브로
### 스키마의 장점

## 데이터플로 모드

### 데이터베이스를 통한 데이터플로
### 서비스를 통한 데이터플로 : REST와 RPC
### 메시지 전달 데이터 플로
