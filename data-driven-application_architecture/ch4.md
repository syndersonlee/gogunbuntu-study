# 4장 부호화와 발전

- 대부분의 경우 기능 변경 = 데이터의 변경

데이터의 변경에 대처하는 데이터 모델의 방법?

- 관계형 데이터베이스의 경우 스키마가 변경
- 읽기 스키마 데이터베이스는 강요 X

대규모 업데이트에 대처하는 코드 변경 방법

- 서버 측 어플리케이션의 경우 몇 개의 노드에 새 버전을 배포하고 이후 나머지를 배포하는 Rolling 배포를 사용
- 클라이언트는 사용자에 의해 좌우

변경 시 중요하게 유지해야하는 점

- 하위 호환성
- 상위 호환성

## 데이터 부호화 형식

- 프로그램은 일반적으로 두 개 이상의 데이터 형태를 사용해 표현
- 포인터 및 바이트 열은 메모리에서 사용하는 데이터 구조와 달라 다른 프로세스에서 이해가 불가능
- In-Memory -> 바이트 열의 변환을 직렬화, 마샬링이라고 지칭 / 반대는 파싱, 역직렬화, 언마샬링

### 언어별 형식

프로그래밍 언어에 내장되어 있는 직렬화 문법의 어려운 점이란?

- 부호화를 통해 저장하고 전송할 경우 현재 프로그래밍 언어로 전송해하고 다른 언어와 통합에 방해
- 복호화 과정에서 임의의 클래스를 인스턴스화 가능해야 하며, 이는 공격자가 원격으로 임의의 코드를 실행할 수 있음
- 버전 관리 과정에서 상하위 호환성이 등한 시
- 효율성이 떨어지는 점

### JSON과 XML, 이진 변형

- JSON, XML, CSV는 텍스트 형식 및 사람이 읽을 수 있음

피상적인 문법 이외에 가지고 있는 미묘한 문제

- XML, CSV는 수와 숫자 문자열 구분이 어려움 / JSON은 문자열과 수를 구분 그러나 부동소수점 수 및 정밀도 미지정
- 큰 수를 다룰 때 JSON에서 문제가 발생
- JSON과 XML은 유니코드는 잘 지원 그러나 이진 문자열은 미지원하여 Base64를 사용하는데 이 때 데이터 크게 33% 증가
- XML의 스키마는 꽤 널리 사용, JSON 기반 도구는 스키마를 미강제 하기 때문에 부호화 시에 하드코딩 해야한느 가능성 존재

위와 같은 문제들이 있음에도 다양한 용도로 사용하기 충분

#### 이진 부호화

- JSON은 XML보다 덜 장황하지만 이진 부호보다 훨씬 많은 공간 사용
- 특정 JSON 형태는 모든 객체의 필드 이름을 포함 해야함

### 스리프트와 프로토콜 버퍼

- 스리프트와 프로토콜 버퍼는 같은 원리를 기반으로 한 이진 부호화 라이브러리 
- 부호화할 데이터를 위한 스키마 필요
- 스키마의 레코드를 부호화하고 복호화할 수 있음

스리프트 스키마 예시

```
struct Person {
    1: required string userName,
    2: optional i64 favoriteNumber,
    3: optional list<string> interests
}
```

프로토콜 버퍼 예시

```
message Person {
    required string user_name = 1;
    optional int64 favorite_number = 2;
    repeated string interests = 3;
}
```

스리프트의 부호화 데이터 형태

- 바이너리 프로토콜
- 컴팩트 프로토콜

바이너리 프로토콜과 스리프트 프로토콜 차이점

- 스리프트 프로토콜은 필드이름이 없고 필드 태그를 통해 필드를 알 수 있음
- 컴팩트 프로토콜은 동일한 데이터를 필드 타입과 태그 숫자를 단일 바이트로 줄여 용량을 줄임
- 프로토콜은 비트를 줄여 처리하는 방법은 다르지만 컴팩트 프로토콜과 비슷함

#### 필드 태그와 스키마의 발전

상위 호완성

- 스키마가 변경됨에 따라 새로운 태그 번호를 부여할 수 있음
- 필드 태그는 변경 될 수 없음으로 필드에 새로운 태그 번호를 부여하여 필드 태그를 추가

하위 호완성

- 새로운 필드를 required로 추가한 경우 예전 코드는 새로운 필드를 미기록하여 읽기 실패
- 이를 위해 optional로 제공하거나 기본값을 가져야 함

필드 삭제 시
- optional 필드만 삭제 가능하고 같은 태그 번호는 절대 다시 사용할 수 없다.

#### 데이터 타입

데이터 타입을 변경 할 경우 
- 32비트를 64비트 정수로 바꿀 경우 누락한 비트를 0으로 채울 수 있기 때문에 쉽게 읽을 수 있음
- 예전 코드를 읽기 위해 32비트를 그대로 사용

프로토콜 버퍼의 repeated 표시자

- 단순한 필드 태그가 여러 번 등장
- optional -> repeated로 변경해도 문제 없음

스리프트의 전용 목록 데이터 타입은 

- 프로토콜 버퍼와 다르게 다중값으로의 변경은 미허용
- 중첩된 목록 허용





### 아브로
### 스키마의 장점

## 데이터플로 모드

### 데이터베이스를 통한 데이터플로
### 서비스를 통한 데이터플로 : REST와 RPC
### 메시지 전달 데이터 플로
