# 7장 트랜잭션

데이터베이스 시스템에서 발생할 수 있는 문제들이란?

- 소프트웨어 및 하드웨어 자체의 결함
- 어플리케이션 연산 중 중단
- 네트워크 통신 중단
- 동시 연산 시 덮어 쓰기 문제
- 부분적 갱신으로 인한 비정상 데이터 읽음 문제
- 클라이언트 사이의 Race Condition 문제

트랜잭션의 특징

- 트랜잭션 내의 읽기와 쓰기를 하나의 묶음 처리
- 모두 OK 하거나 모두 Fail

## 애매모호한 트랜잭션의 개념

- NOSQL의 발전 / 복제 파티션 / 고가용성의 반대되는 개념으로 트랜잭션의 특징들이 줄어야 한다는 의견들이 존재

### ACID의 의미

| | ACID | BASE |
| -- | -- | -- |
| 안정성 보장 수준 | 엄격 | 느슨 |
| 특징1 | 원자성 | 가용성 (Basically Available) | 
| 특징2 | 일관성 | 유연한 상태 (Soft State) |
| 특징3 | 격리성 | 최종적 일관성 (Eventually consistency) |
| 특징4 | 지속성 | |

#### 원자성

- 더 작은 부분으로 쪼갤 수 없는 특성
- 하나의 스레드 프로그래밍에서 절반만 처리할 수 없는 것과 같은 원리
- 하나의 단위에서 전체를 abort할 수 있는 개념이 더 정확

#### 일관성

- 여러 의미를 함축
    - 최종적 일관성
    - 어플리케이션 단위에서의 속성
    - 모든 파티션과 다른 위치의 DB 간의 데이터가 일치해야한다는 의미

#### 격리성

- 직렬성과 비슷한 의미
    - 처리간의 순서가 순차적으로 처리 되었을 때의 결과와 동일하도록 처리

#### 지속성

- 트랜잭션 내에서 성공적으로 커밋이 되었다면 그 데이터는 손실이 되면 안된 다는 뜻
- 이 전제는 모든 백업 디스크와 데이터베이스가 무결하다는 전제임으로 깨질 경우 이는 보장 불가

#### 복제와 지속성

- 지속성의 의미
    - 디스크의 쓰기
    - 원격 장비에 복제
    - 백업
- 위 방법의 처리로 위험을 줄이는 기법

### 단일 객체 연산과 다중 객체 연산

- 여러 부분의 파편화 된 상태로 동기화가 유지되어야 할 경우에 사용
- 다중 트랜잭션 내에서는 하나의 트랜잭션이 같은 트랜잭션 내에 속하게 하여서 갱신 실패 시 취소

#### 단일 객체 쓰기 

- 동시에 하나의 시스템에서만 격리할 수 있도록 처리
- 예시로 Compare-and-set (Optimistic Locking)

#### 다중 객체 트랜잭션의 필요성

- 쓰기 작업에서 놓치면 안되는 것
    - 관계형 모델에서 FK 관계가 무결성이 유지되어야 함
    - 비정규화 모델에서는 동기화가 깨지지 않도록 동시 갱신 필요
    - 보조 색이 있는 경우 동시 갱신 필요

#### 오류와 어보트 처리

- 오류 복구를 어플리케이션에서 처리하도록 Soft하게 처리 할 수 있음
    - EX) Rails, Django
- abort가 완벽 하지 않은 케이스
    - 네트워크 단절
    - 요청 자체의 결함있는 경우
    - 오류 과부하
    - 클라이언트에서 모든 데이터가 날아가는 경우

## 완화된 격리 수준

- 실제 Race Condition은 잘 발생하지 않는 오류
- 발생 가능 Condition 과 발생 불가능 Condition 소개

### 커밋 후 읽기

커밋 후 읽기 시 보장되는 것

1. 커밋된 데이터만 보게 됨 (더티 읽기 X)
2. 커밋된 데이터를 덮어 씀 (더티 쓰기 X)

#### 더티 읽기 방지

- 트랜잭션 이후의 데이터만 보도록 함
- 더티 읽기 방지 시 이득
    - 잘못된 결정을 하는 원인
    - 롤백 데이터를 볼 시 문제가 될 수도 있음

#### 더티 쓰기 방지

- 일반적으로 두 번째 쓰기를 지연
- 두 번의 카운터 증가 사이에 발생하는 경쟁조건은 막지 못함
- 하나의 트랜잭션 내의 커밋이 안된 값 덮어쓰기 방지 가능

#### 커밋후 읽기 구현

- 일반적으로 로우 수준의 잠금 지원 (오라클 11g, postgreSQL, SQL Server)
    - 더티 쓰기 방지
- 커밋된 이후에 볼 수 있도록 하여 더티 읽기 방지

### 스냅숏 격리와 반복 읽기

- 비반복 읽기 / 읽기 스튜
    - 일관성이 깨진 상태로 데이터를 읽는 것
- 다중 버전 동시성 제어
    - 커밋 버전을 여러 개 유지하는 것

#### 일관된 스냅숏을 보는 가시성 규칙

1. 데이터베이스는 트랜잭션이 시작할 때 목록을 생성하고 나머지는 무시
2. abort 트랜잭션 또한 무시
3. Transaction ID가 작은 것만 적용
4. 그 밖에는 데이터 질의 적용

#### 색인과 스냅샷 격리

| PostgreSQL | 카우치DB, 데이토믹, LMDB |
| -- | -- |
| 같은 페이지 저장 될 시 색인 갱신 회피 | 쓸 때마다 복사 |

#### 반복 읽기와 혼란스러운 이름

스냅샷 격리의 다양한 이름

| 오라클 | PostgreSQL | 
| -- | -- |
| 직렬성 | 반복 읽기 |

### 갱신 손실 방지

- 하나의 값을 변경 후 다시 쓸 경우 발생 하는 문제
- 아래는 해결책들

#### 원자적 쓰기 연산

- 기존의 데이터를 +1 하는 형태로 쿼리 갱신의 경우 문제가 X
- 대안
    - 임의의 텍스트 편집 기능 경우 Lock을 획득해서 구현
        - 커서 안정성
    - 단일 스레드 실행

#### 명시적 잠금 

- 기존 데이터에 Lock을 걸어 놓고 실행

#### 갱신 손실 자동 방지

- 갱신 손실 발견 시 abort 시키고 재시도 처리
- 어플리케이션에서 처리할 내용이 없어짐

#### Compare-and-set

- 데이터가 바뀌지 않았을 시 바꾸는 것
- DB가 오래된 스냅샷을 읽는 다면 방지 불가

#### 충돌 해소와 복제

- 데이터의 최신 복제본이 여러 군데에 있을 경우 C&S는 사용 불가
- 동시 쓰기 감지 처럼 여러 버전에서 Commit 하는 것 처럼 병합
- LWW는 갱신 손실 발생 위험이 큼

### 쓰기 스큐와 팬텀

- 큐에서 데이터를 취소할 경우 최소 대기를 충족해야하는 큐에서 데이터가 0이 되는 케이스 발생 가능

#### 쓰기 스큐를 특징짓기

- 단일 객체 연산에서 해결 불가
- 직렬성 격리가 필요
- 트랜잭션에 의존하는 Row를 잠그는 것이 차선

#### 쓰기 스큐의 예

- 회의실 예약 시스템
    - 직렬성 격리 필요
- 다중플레이어 게임
- 사용자명 획득
    - 유일성 제약 조건
- 이중 사용 방지

#### 쓰기 스큐를 유발하는 팬텀

- 쓰기가 다른 케이스의 질의 결과를 바꾸는 경우
    - 팬텀
    - 쓰기 스큐의 까다로운 경우 유발

#### 충돌 구체화

- 충돌 나는 부분을 정리해서 구체화 해서 해당 범위에 대한 Lock을 제공
    - 구체화 하기 어렵고 오류 발생이 쉬운 단점
    - 동시성 메커니즘이 어플리케이션 단위로 나오는 단점

## 직렬성

- 까다로운 Race Condition의 종류
    - 이해하기 어려운 격리 수준 / DB마다 구현의 일관성 차이
    - 어플리케이션 코드에서 격리 수준 파악 어려움
    - Race Condition 감지가 어려움
- 해결책 : 직렬성 격리
- 직렬성 격리의 3가지 구현 기법
    - 트랜잭션 순차적 실행 (실제적인 직렬 실행)
    - 2단계 잠금
    - 직렬성 스냅숏 격리 (낙관적 동시성 제어)

### 실제적인 직렬 실행

- 동시성을 완전히 제거하는 방법
- 기술의 발전으로 인해 가능
    - 램 가격이 저렴해 짐에 의해 데이터셋 전체를 메모리에 유지 할 수 있어야 함
    - OLTP 트랜잭션이 보통 짧기 때문에 실제적 직렬 실행 가능 / OLAP의 경우 스냅숏 격리를 사용

#### 트랜잭션을 스토어드 프로시저 안에 캡슐화 하기

- 트랜잭션 처리 중 사람의 상호 작용이 들어가는 부분은 매우 느림
- 트랜잭션 처리 시 하나의 질의 씩 실행 할 경우 네트워크 통신이나 DB 통신 사이에 긴 시간이 걸림
- 이를 해결 하기 위해 트랜잭션 코드 전체를 <b>스토어드 프로시저</b> 형태로 제출

#### 스토어드 프로시저의 장단점

| 단점 | 개선 방안 |
| -- | -- |
| 전용 언어를 사용하고 조잡하며 생태계가 약하여 코드 관리가 어려움 | 범용 프로그래밍 언어 사용하여 단점 극복 하도록 처리 | 
| 성능에 훨씬 민감 | 단일 스레드 처리를 통해 오버헤드를 줄여 처리 |

#### 파티셔닝

- 싱글 CPU에선 단일 코어 CPU 속도로 제한
    - 쓰기 처리량이 높을 경우 병목 현상
- 위 문제를 해결하기 위해 데이터 파티셔닝을 하여 처리 성능을 확장
- 코디네이션 오버헤드 때문에 단일 파티셔닝보다 느림

#### 직렬 실행 요약

- 트랜잭션 직렬 실행의 경우 아래 4가지의 케이스에 대해서 실용적
    - 모든 트랜잭션은 작고 빨라야 한다.
    - 메모리에 적재될 수 있는 경우
    - 쓰기 처리량이 CPU 코어에서 처리할 수 있는 정도 -> 멀티 파티션은 속도가 느림

### 2단계 잠금 (2PL)

- 읽기와 쓰기 모두에 대해서 잠금을 진행
- 객체에 대한 잠금을 사용하여 구현
    - 공유 모드 (shared mode) / 독점 모드 (excludsive mode)
    - 공유 잠금
        - 읽기 시 다른 시스템에도 읽기는 가능 하되, 쓰기는 불가능한 잠금
    - 독점 모드
        - 쓰기를 진행할 때 획득 필요, 다른 모든 시스템에서는 해당 잠금에 접근 불가
- 서로 간의 잠금의 대기를 기다리는 상태
    - Deadlock
    - 강제로 한쪽을 abort 시켜서 진행하도록 처리 필요

#### 2단계 잠금의 성능

- 타 트랜잭션을 기다려야 함으로, 성능이 안 좋아 짐
- 교착 상태가 잦아질 수 있으므로, 헛수고가 심해질 수 있음

#### 서술 잠금

- 특정 검색 조건에 해당하는 객체에 대해 잠금을 진행

#### 색인 범위 잠금

- 서술 잠금을 간략하게 근사 처리
- 색인 조건이 여러 가지가 존재시 하나 혹은 적은 개수의 색인에 대해서 전부 잠금 처리하여 성능은 좋지 않지만 안전하게 처리 가능
 
### 직렬성 스냅숏 격리 (SSL)

- 완전한 직렬성을 제공하는 알고리즘
- 약간의 성능 손해 존재하지만 큰 차이 없음

#### 비관적 동시성 제어 대 낙관적 동시성 제어

- 직렬성 스냅샷 처리는 낙관적 동시성 제어
- 격리 위반 시 롤백 처리하는 방법으로 구현
- 기존 낙관적 동시성 처리와 다른 점
    - 스냅샷 격리 위에 직렬성 충돌을 감지

#### 뒤처진 전제에 기반한 결정

- 질의의 결과가 최신이 아닐 수도 있음
- 위 결과를 탐지하는 두 가지 기법
    - MVCC 구버전을 읽었는 지 확인하는 방법
    - 과거의 읽기에 영향을 미치는 쓰기 실행 시

#### 오래된 MVCC 읽기 감지

- 다른 트랜잭션의 쓰기를 무시하는 경우 탐지
- 커밋된 내용을 확인 했을 때 트랜잭션을 abort
    - 후에 나오는 것이 바로 abort 하지 않는 이유는 읽기 전용 트랜잭션일 수도 있기 때문에

#### 과거의 읽기에 영향 미치는 쓰기 감지

- 읽기 정보에 대한 정보를 트랜잭션이 완료하기 전까지만 저장
- 읽던 정보가 변경이 될 경우 후발 트랜잭션에게 변경 여부를 통지
- 후발 트랜잭션이 충돌하는 쓰기에 커밋하길 원할 경우 abort

#### 직렬성 스냅숏 격리의 성능 (SSI)

- 알고리즘 사이에 가장 큰 트레이드 오프는 읽기/쓰기를 추적하는 세밀함 차이
- 2단계 잠금에서 나오지 않는 직렬성 스냅숏 격리의 큰 이점
    - 잠금 대기에 필요한 차단이 필요 없음
- SSI는 abort 비율은 성능에 큰 영향

