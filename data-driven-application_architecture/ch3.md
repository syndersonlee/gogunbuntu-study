# 3장 저장소와 검색

데이터 베이스의 역할이란?

- 데이터를 저장
- 저장한 데이터를 호출

이 장의 목표

- 작업에 따른 적합한 엔진 채택을 위해 저장소 엔진이 수행하는 작업을 이해
- No SQL 저장소 엔진 분석
    - 로그 구조 계열 저장 엔징
    - 페이지 지향 계열 저장소 엔진

## 데이터베이스를 강력하게 만드는 데이터 구조

가장 기본적인 구조의 DB

- Key - Value 형태의 DB
- 예전 값을 덮어 쓰지 않고 파일의 끝에 추가
- DB에 값이 많을 수록 검색 비용이 큼
- 검색 비용을 줄이기 위한 방법 = 색인

색인의 특징

- 기본 데이터에서 파생된 추가적인 구조
- DB의 내용과는 별개로 다룸
- 쓰기 과정에서 오버헤드 발생

### 해시 색인

색인 전략 종류

- 키를 데이터 바이트 오프셋에 매핑하여 해시 맵 유지 - 비트캐스크
    - 키의 값이 자주 갱신 되는 경우
    - 데이터 파일의 일부가 파일 캐시에 있다면 읽기에 디스크 출력 X

- 특정 크기에 도달하였을 때 세그멘트로 로그를 나누는 방식 - 컴팩션
    - 하나의 파일을 만들고 세그먼트 병합 후 이전 세그먼트 삭제
    - 구현에서 중요한 요소
        - 파일형식 : 바이너리 방식 사용
        - 레코드 삭제 : 레코드 삭제 과정에서 이전에 추가된 값을 무시
        - 고장 복구 : 세그 먼트 값이 크면 복구가 어려움
        - 부분적 레코드 쓰기 : 체크섬을 통해 손상된 부분만 탐지 후 복구 가능
        - 동시성 제어 : 쓰기를 엄격하게 할 경우 쓰기 쓰레드를 하나만 사용

- 추가 전용 설계의 장점
    - 순차적인 쓰기 작업이라 훨씬 빠름
    - 추가 전용이라 고장 복구가 훨씬 간편

- 단점
    - 메모리 저장하는 내용이라 키가 많으면 문제
    - 확장 비용이 비쌈
    - Range Scan이 비효율

### SS 테이블과 LSM 트리

SS테이블 - 세그먼트 파일 형식과 다른 점

- 키-값 쌍을 키로 정렬
- 가장 최근의 세그먼트 값만 유지
- 모든 값을 알 필요 없고 가까운 오프셋에서 이동하는 방시긍로 찾기 가능

#### SS 테이블 생성과 유지

키 정렬 방법
- 유입되는 쓰기는 임의의 순서로 발생

저장소 엔진 만드는 방법
- 쓰기가 들어오면 Red-black Tree 같은 자료구조에 데이터 추가 - 트리를 멤테이블이라 부름
- 새로운 SS테이블 파일은 데이터베이스의 가장 최신 세그멘트
- 백그라운드에서 컴팩션 과정을 수행

#### SS 테이블에서 LSM 트리 만들기

알고리즘 적용 DB

- 레벨 DB
- 록스 DB
- 유사 - 카산드라, Hbase

루씬
- 엘리스틱 서치나 솔라에서 사용하는 전문 검색 엔진
- 단어에 대한 모든 문서를 Key-Value로 구현
- 키는 단어, 값은 단어를 포함한 모든 ID List

#### 성능 최적화

LSM 트리 알고리즘의 단점

- 존재 하지 않는 필터 검색 시 모든 데이터 탐색 필요
- 이를 대응하기 위한 블룸 필터 사용

SS테이블을 압축하고 병합하는 순서와 시기를 결정하는 전략

- 크기 계층
- 레벨 컴팩션

LSM 트리의 기본 개념

- SS테이블을 지속 병합
- 높은 쓰기 처리량 보장

### B 트리

특징

- 블록이나 페이지로 나누면 하나의 페이지 쓰기와 읽기를 진행
- 페이지 트리 형태로 구현
- 새로운 키에 빈칸이 없을 때, 하나를 반쯤 채워진 두 페이지로 분리

#### 신뢰할 수 있는 B트리 만들기

- B트리의 기본적인 동작은 물리 데이터를 덮어 씀
- 덮어 쓰기는 DB가 중간 고장 시에 위험 할 수 있으니 쓰기 전 로그를 남겨야 함
- Latch(가벼운 잠금을 통해 데이터 구조 보호)

#### B 트리 최적화

- 덮어 쓰기와 복구 작업을 위해 쓰기 시 복사 방식 사용
- 전체 키를 저장하는 것이 아니라 경계 역할만 저장하고 하나의 페이지에 많은 키를 저장하려고 함
- B트리에서는 페이지를 연속된 순서로 놓기 위해 시도

### B 트리와 LSM 트리 비교 

- B트리가 읽기에 더 최적화 되어 있고, LSM 트리가 쓰기에서 빠름

#### LSM 트리의 장점

- B트리는 쓰기 전 로그와 트리 페이지 입력 시 두번 입력
- LSM 트리의 경우 쓰기 증폭이 낮고 컴팩션된 SS 테이블만 씀
- LSM 트리는 압축률이 좋음
- SSD에서 낮은 쓰기 증폭과 파편화 감소 측면에서 좋음

#### LSM 트리의 단점

- 컴팩션 과정이 성능에 영향을 줌
- 높은 쓰기 처리량 때문에 로깅과 디스크 방출 과정에서 리소스 공유
- 컴팩션이 쓰기 속도를 못 따라가는 경우 디스크 공간 부족 문제 또한 발생
- 키가 다양한 곳에 존재 할 수 있기 떄문에, 트랜잭션 측면에서 B트리 보다는 약함

### 기타 색인 구조

- 관계형 테이블의 기본 구조는 기본키 색인 / 보조 색인을 사용
- 같은 키를 가진 많은 로우가 존재 가능

#### 색인 안에 값을 저장 하기

힙 파일

- 특정 순서 없이 데이터를 저장
- 키 값을 변경하지 않고 값을 갱신할 때 효율적
- 이전 값의 포인터를 새 위치로만 변경하면 되기 때문

클러스터드 색인

- 힙파일로 이동하지 않고 색인 위치에 데이터 저장하는 것
- MySQL InnoDB에서는 기본키가 Clustered Engine이고 보조 색인은 기본키
- 절충안은 covering index나 index with included column이라 함

#### 다중 칼럼 색인

- 테이블의 다중 칼럼이나 동시 색인이 필요한 경우 불충분

결합 색인

- 하나의 칼럼에 다르칼럼을 추가하는 방식

다차원 색인

- 한 번에 여러 칼럼에 질의하는 일반적인 방법
- 2차원 지도에서 특정 식당을 찾는 경우 사용
- 공간 채움 곡선을 통해 B트리를 사용 (PostgreSQL의 R트리 사용)

#### 전문 검색과 퍼지 색인

애매 모호 (fuzzy) 질의 시

- 특정 단어의 동의어 질의를 확장
- 특정 편집 거리 내 단어 검색
- 트라이 구조로 검색

#### 모든 것을 메모리에 보관

- MemCached 나 Redis를 통해 메모리를 저장
- LRU 방식을 이용해 사용하지 않는 데이터를 메모리로 보내고 디스크에서 불러오는 안티 캐싱 방식으로 동작

## 트랜잭션 처리와 분석?

커머셜 트랜잭션

- 비즈니스 데이터 처리의 기본

온라인 트랜잭션

- 대화식으로 사용자 입력 기반으로 삽입
- 위 두 가지 정보를 통해 BI(Bussiness Intelligence)를 생성하여 사업 방향을 결정

OLTP (트랜잭션 처리 시스템) vs OLAP (분석 시스템)

| 특성 | OLTP | OLAP |
| -- | -- | -- |
| 읽기 패턴 | 레코드가 적고 키 기준 | 많은 레코드 집계 | 
| 쓰기 패턴 | 랜덤 엑세스 | ETL, 대규모 이벤트 스트림 |
| 사용처 | 어플리케이션을 통한 사용자 | 내부 분석가 |
| 표현 | 최신 상태 | 이벤트 로그 |
| 데이터 크기 | GB ~ TB | TB ~ PB |

### 데이터 웨어 하우징

- OTLP 작업에 영향을 주지 않고 마음껏 질의 할 수 있는 시스템
- ETL를 가져옴

#### OLTP 데이터베이스와 데이터 웨어 하우스의 차이점

- 분석가가 드릴다운, 슬라이싱, 다이싱을 통해 데이터를 탐석할게 도와주는 데이터 분석 도구가 있음
- SQL 서버와 SAP HANA 같은 일부 DB는 트랜잭션 처리와 데이터하우징을 지원
- 일반적으로 값비싼 상용 라이센스로 판매 

### 분석용 : 별 모양 스키마와 눈꽃송이 모양 스키마

사실 테이블

- 개별 이벤트를 담음
- 차원 테이블이라 부르는 외래 키 참조
- 하나의 사실에 대해 개별 Row가 하나 생성

별 모양 스키마

- 중앙에 하나의 Fact가 있고 다른 차원 테이블이 둘러 싸고 있는 형태

## 칼럼 지향 저장소

- 모든 값을 하나의 로우에 저장하지 않음
- 각 칼럼별로 모든 값을 함께 저장

### 칼럼 압축

비트맵 부호화

- 고유 값의 유무에 따라 1과 0으로 표기하는 방법

#### 메모리 대역폭과 벡터화 처리

데이터베이스 질의 병목의 문제점

- CPU 캐시에서 데이터 호출 시 압축되어 있는 칼럼 데이터를 가져올 때 한 번에 더 가져오기 위해 정리가 필요
- 이를 위해 벡터화 처리 기법을 거침

### 칼럼 저장소와 순서의 정렬

- 질의 특성에 따라 정렬
- 첫 번쨰의 질의에서 가장 강력

#### 다양한 순서 정렬

로우 지향저장 vs 칼럼 지향 저장

- 로우 지향 저장은 색인에 한 곳에 모든 로우를 유지하고 2차 색인은 일치하는 로우를 가리키는 포인터만 포함
- 칼럼 지향 저장에서는 데이터를 가리키는 포인터가 없고, 값을 포함하는 칼럼만 존재

### 칼럼 지향 저장소에 쓰기

칼럼 지향 저장소의 최적화 특징

- 읽기 질의가 빠르고 쓰기가 어려움
- 로우가 모든 테이블에 일관성 있게 삽입이 필요

### 집계 : 데이터 큐브와 구체적 뷰

구체화 집계

- 자주 사용하는 질의를 캐싱
- 구체화 뷰 - 데이터 큐브라는 집계를 사용

## 정리

- 