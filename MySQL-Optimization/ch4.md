# ch4 운영체제 하드웨어 최적화

## MySQL의 성능을 제한하는 요소

- 대부분은 CPU 성능 고갈로 인한 이슈가 많이 발생
    - 현재는 SDD 사용으로 인해 I/O 성능 저하 체감이 둔화

## MySQL용 CPU를 선택하는 방법

- 중요 쿼리에 대한 CPU 사용률과 I/O 균형률 수치가 핵심
    - 짧은 대기 시간
    - 높은 처리량

## 메모리 및 디스크 리소스의 균형 유지

- 메모리 접속으로 인한 I/O 시간이 디스크 I/O 보다 훨씬 빠름

### 읽기, 쓰기, 캐싱

- 읽기의 경우 캐시 히트로 메모리의 논리적 읽기로 성능 커버가 가능
- 쓰기의 경우 캐시로 쓰기 지연은 가능하나 배제는 불가능
- 쓰기를 그룹화 하는 두 가지 옵션
    - 다수의 쓰기, 한 번의 플러시
        - 카운터를 두고 그 수치 이후 Flush를 통해 디스크에 적용하는 형태
    - I/O 병합 (?)
- 랜덤 I/O가 수행되지만 선행 로그 기법을 진행 후 디스크에 플러시하여 쓰기를 최적화

### 작업 세트란?

- 실제 작업을 수행하는 데에 필요한 작업의 모음들
- HDD를 사요할 경우 효과적인 디스크와 메모리 비율을 찾는 것이 중요

## 솔리드 스테이트 스토리지

- 매우 큰 OLAP 시스템이나 데이터 웨어 하우스 및 레거시 시스템이 아닐 경우 일반적으로 SDD를 사용
- 자기 플래터 대신 셀로 구성된 비휘발성 메모리 메모리 칩(NVRAM)을 사용
- NVRAM 성능 특징
    - 하드 드라이브에 비해 랜덤 읽기 및 쓰기 성능이 우수
    - 순차 읽기 성능 및 쓰기 성능이 뛰어남
    - 동시성 기능 지원이 뛰어남

### 플래시 메모리 개요

- 플래시 메모리의 특징
    - 짧고 여러 번 읽는 데 효과적
    - 쓰기에 어려움
        - 새로운 쓰기가 필요할 때 특별한 지우기가 필요
        - 장치가 페이지를 잘 배치해야 함
        - 쓰기 증폭
            - 부분 블록 쓰기로 인한 데이터 이동

### 가비지 컬렉션

- 새로운 쓰기를 위해서 일부 블록을 깨끗하게 유지하기 위한 <b>쓰기 증폭 계수</b> 증가
- 장치가 가득 찰 수록 속도가 지연

## RAID 성능 최적화

- RAID는 데이터를 많이 저장하기에 좋은 옵션
- RAID 옵션
    - RAID 0
        - 가장 저렴하고 성능이 뛰어난 구성
        - 중복성을 제공하지 않음
    - RAID 1
        - 디스크 용으로 데이터를 복제
        - 로깅 및 비슷한 워크 로드 처리 시 이점을 가짐
    - RAID 5
        - 여러 디스크에 데이터 블록을 분산해서 저장
        - 디스크에 장애가 생겼을 경우 모든 디스크를 읽어 재구성 필요
        - 컨트롤러의 캐시 성능과 직결
    - RAID 6
        - 디스크 2개의 손실이 치명적
        - 디스크가 많아질 수록 장애가 많아짐
    - RAID 10
        - 스트라이프 되어 있고 미러링 된 쌍으로 구성
        - RAID 5에 비해 빠르고 쉽게 구축 가능
    - RAID 50
        - RAID 5 어레이로 구성되어 있음
        - 디스크가 많은 경우 5의 경제성과 10의 성능을 절충
        - OLTP에 자주 사용

| 레벨 | 중복 | 필요 디스크 | 읽기 가속 | 쓰기 가속 | 요약 |
| -- | -- | -- | -- | -- | -- |
| RAID 0 | 불가 | N | 가능 | 가능 | 저렴함, 위험 |
| RAID 1 | 가능 | 2 | 가능 | 불가 | 빠른 읽기, 간편함, 안전함 |
| RAID 5 | 가능 | N + 1 | 가능 | 상황에 따라 다름 | SSD로 저렴하고 빠름 |
| RAID 6 | 가능 | N + 2 | 가능 | 상황에 따라 다름 | RAID 5와 유사하지만 복원력이 더 뛰어남 |
| RAID 10 | 가능 | 2N | 가능 | 가능 | 고가, 빠름, 안전함 |
| RAID 50 | 가능 | 2(N + 1) | 가능 | 가능 | 매우 큰 데이터 저장소 목적 |

### RAID 장애, 복구 및 모니터링

- 가장 중요한 요소는 RAID 어레이 모니터링
- 에레이 길이가 길수록 검사에 많은 시간 소요
- 디스크가 많을 수록 고장 확률이 증가
- 배터리 장애 시 라이트백 캐시 -> 동시 쓰기로 캐시 정책 변환
    - 이로 인한 성능 저하 가능
- `innodb_flush_log_at_trx_commit` 및 `sync_binlog` 변수를 낮은 지속성 서버로 변경 처리
    - 디스크 사용률이 낮아지고 적절한 성능 제공 가능
    - 데이터 베이스 중단 시 손실될 수 있는 양 증대

### RAID 구성 및 캐싱

- 컨트롤러의 가장 중요한 속성   
    - 청크 크기
    - 컨트롤러 캐시

#### RAID 스트라이프 청크 크기

- 일반적으로는 청크 크기가 클수록 랜덤 I/O 성능이 좋음
- 다만 이론과는 다르게 청크 크기가 너무 큰 경우 데이터 캐싱 시 효율성이 떨어짐

#### RAID 캐시

- RAID 카드가 캐시를 사용할 수 있는 이유
    - 캐싱 읽기
        - OS 캐시와 DB 캐시가 상위 속성이고 일반적으로 이곳에서 캐싱이 이루어져 함
    - 미리 읽기 데이터 캐싱
        - 순차적 요청 시 해당 데이터에 대한 예상을 선행하여 캐싱
    - 쓰기 캐싱
        - 물리적 디스크에서 쓰기를 수행할 때 보다 빠르게 성공 반환 가능
        - 쓰기를 누적하여 효율성 향상
    - 내부 작업
- 하드 디스크는 디스크에 flush되지 않은 상태에서 거짓말 할 가능성이 있음
    - 위 내용을 처리하기 위해서 전원을 몇 시간 동안 꺼놓을 필요성이 있음

## 네트워크 설정

- 네트워크 병목 현상은 MySQL 통신 간의 주요 성능 병목 원인
- 제일 중요한 것은 많은 연결과 작은 쿼리를 효율적으로 처리 할 수 있는 설정 조정
    - 로컬 포트 범위 변경을 넓히는 방식으로 해결

## 파일시스템 선택하기

- mySQL InnoDB와 잘 어울리는 파일 시스템은 일반적으로 ext4, XFS, ZFS같은 저널링 파일 시스템
- ext4를 사용할 경우 마운트 옵션
    - 메타데이터 쓰기만 저널링
    - 메타데이터 + 일부 데이터
    - 데이터를 최종 위치에 기록하기 전에 저널에 씀 = 가장 많은 오버헤드
- 일반적으로 XFS 파일 시스템이 선호
    - ext3는 inode당 단일 뮤텍스 제한이 있음
    - ext4의 경우 성능 병목 현상 발생 가능성 존재

### 디스크 큐 스케줄러 선택

- 디스크 큐 스케쥴러의 기본값은 cfq(Completely Fair Queuing)
- 서버에서는 응답 시간이 매우 느려짐
    - noop 스케쥴러 - RAID 컨트롤러 및 SAN에 적합
    - 데드라인 스케쥴러 - RAID 컨트롤러 및 직접 연결된 디스크에 적합

### 메모리와 스와핑

- mySQL에 많은 메모리가 할당 되는 것은 성능 상으로 당연히 이점이 있음
- 다만 이로 인해 운영체제에 메모리가 모자라 스와핑 현상이 발생하면 디스크에 무리를 주어 mySQL 프로세스 중 일부를 강제 종료 시켜 mySQL에 무리를 줄 수 있음

### 운영 시스템 상태

- 리눅스 커널 상 메모리 모니터링 도구
    - vmstat
        - 명령어 종류
            - procs
                - CPU 시간을 대기하는 프로세스 수
            - memory
                - 스왑 아웃된 블록 수
            - swap
                - 스왑 활동을 하는 초당 블록 수
            - io
                - io활동을 하는 초당 블록수
    - iostat
        - r/s, w/s
            - 초당 장치에 전송된 읽기 및 쓰기 요청 수
        - rkB/s, wkB/s
            - 초당 읽고 쓴 키로바이트 수
        - await
            - 디스크 큐에서 소요된 밀리초 단위의 시간
- 장치가 처리하는 동시 요청 수에 대한 공식
    - concurrency = (r/s + w/s) * (svctm/1000)

### 그 외 유용한 도구들

- 위 두 도구가 요구 사항을 충족하지 못하는 경우
    - mpstat - CPU 통계
    - blktrace - 디스크 사용량 통계
    - 