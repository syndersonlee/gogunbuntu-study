# ch7 고성능을 위한 인덱싱

- 인덱스 최적화는 쿼리 성능을 향상 시키는 좋은 방법
- 인덱스는 종종 실제 성능의 주요한 문제가 됨

## 인덱싱 기본

- MySQL에서 인덱스는 책의 색인 처럼 동작
- 인덱스는 테이블에 있는 하나 이상의 열의 값을 포함
- ORM의 도구에 의존하더라도 인덱싱에 의존
    - 대부분의 케이스에서 올바른 쿼리를 생성하지만
    - 기본 키 조회 같은 간단한 쿼리가 아닌 이상 기타 쿼리에서는 문제가 발생 가능

### 인덱스 유형

- 서버 계층이 아닌 스토리지 엔진 계층에서 인덱스 구현
- MySQL이 지원하는 지원하는 가장 일반적으로 사용하는 두 가지 인덱스 유형
    - B트리 인덱스
    - 적응형 해시 인덱스

#### B-트리 인덱스

- NDB Cluster 엔진은 BTREE로 레이블 지정 / InnoDB는 B+ 트리를 사용
- B-트리 인덱스는 스토리지 엔진이 원하는 데이터를 찾기 위해 전체 테이블을 스캔할 필요 없음
    - 데이터 엑세스 속도 향상
    - 리프 페이지는 인덱싱 되어 있는 데이터에 대한 포인터를 가지고 있음
- 적응형 해시 인덱스
    - 일부 인덱스 값이 매우 자주 엑세스되고 있음을 감지 시 메모리 해시 인덱스 구축

#### B-트리 인덱스를 사용할 수 있는 쿼리 유형

- 전체 값 일치
- 맨 왼쪽 접두사 일치
- 값 범위 일치
- 한 부분을 정확히 일치시키고 다른 부분의 범위와 일치
- 인덱스 전용 쿼리 (커버링 인덱스)

#### 인덱스 제한 사항

- 인덱싱 가장 왼쪽에서 조회가 시작되지 않으면 유용하지 않음
- 인덱스 열을 건너뛸 수 없음
- 스토리지 엔진은 첫 번째 범위 조건의 오른쪽 열을 사용한 액세스 최적화 불가능

#### 풀 텍스트 인덱스

- 인덱스 값을 직접 비교하는 것이 아닌 텍스트에서 키워드를 찾는 특수 유형의 인덱스
- 단순한 WHERE 매개 변수 매칭 X -> 검색 엔진이 하는 작업과 유사

### 인덱스의 이점

- B-트리 인덱스는 데이터를 정렬된 순서로 저장
- 이점
    - 서버가 검사해야하는 데이터 양 감소
    - 정렬 및 임시 테이블 생성 방지
    - 랜덤 I/O를 순차 I/O로 변환

## 고성능을 위한 인덱싱 전략

### 프리픽스 인덱스 및 인덱스 선택성

- 전체 값 대신 처음 몇 개의 문자를 인덱싱 하는 방법
    - 공간 절약 및 성능 향상 가능
    - 고유 인덱스 선택성이 1일 경우, 더 좋을 순 없음
    - 프리픽스 형태의 인덱스의 경우 우수한 성능을 제공하는 경우가 많음
    - 매우 긴 VARCHAR이나 TEXT 열은 반드시 정의 필요

### 다중 열 인덱스

- 많은 열에 대한 개별 인덱스는 훨씬 더 느릴 가능성이 존재
- MySQL의 **인덱스 병합**으로 여러 인덱스를 병합하여 원하는 행을 찾을 수 있음
    - OR 조건의 합집합
    - AND 조건의 교집합
    - 두 조건의 조합에 대한 교차 되는 부분의 합집합
- 위 인덱스가 잘 적용 되지 않는 경우
    - 서버가 인덱스를 교차할 때
    - 서버가 인덱스를 통합 할 때 OR 조건일 경우
    - 옵티마이저는 위 비용을 고려하지 않으므로 쿼리를 더 엉망으로 만들 가능성 존재

### 좋은 열 순서 선택하기

- 여러 열로 구성된 B-트리 인덱스에서 열의 순서는 순차 탐색
- 따라서 정방향 혹은 역방향으로 쿼리 충족 가능
- 가장 중요한 것은 선별적인 열을 먼저 배치하는 것
    - 더 적은 수의 행을 배치하는 것이 유리
- 경험적 경험 법칙과 경험적 방법이 유용 할 수 있음

### 클러스터형 인덱스

- 데이터 스토리지에 대한 배치 방식
- 일부 데이터베이스에서는 클러스터 인덱스는 Optional이지만 MySQL은 불가능
- 클러스티링의 이점
    - 관련 데이터를 서로 가까이 보관할 수 있음
    - 데이터 엑세스 속도가 빠름
    - 커버링 인덱스를 사용하는 쿼리는 기본 키 값 사용 가능
- 단점
    - I/O 바운드 워크 로드를 크게 개선하므로 액세스 순서는 큰 영향 X
    - 삽입 순서에 따라 삽입 속도가 빨라짐
    - 기본키가 없어질 경우 페이지 분할 대상으로 처리

#### InnoDB 데이터 레이아웃

- 물리적 테이블은 보조 인덱스 리프 노드에 기본 키  값 포함
- 클러스터 인덱스에서 기본 키값, 트랜잭션 ID, 롤백 포인터 및 col2를 포함
- InnoDB의 비 Leaf Node는 깊은 노드에 대한 포인터를 포함

#### InnoDB를 활용하여 기본 키 순서로 행 삽입

- 특정 클러스터링이 필요가 없는 경우 **대리 키** 정의가 좋음
- 위 키는 AUTO_INCREMENT 사용이 좋음
- UUID는 성능 관점에서 안좋음
    - AUTO_INCREMENT는 새 데이터를 삽입 시 기존 노드 뒤에 들어감
    - UUID는 중간 중간에 삽입 되므로 추가 작업 발생
        - 이에 따라 랜덤 I/O 발생
- 다만, InnoDB Key 상승 시 해당 지점에서 Race Condition 발생 가능

### 커버링 인덱스

- 인덱스만 읽어 성능을 향상 시키는 방법
    - 적은 데이터 엑세스
    - 적은 I/O 수행 및 순차적 엑세스 가능
    - 클러스터형 인덱스 구조 때문에 유리
- 인덱스에만 해당하는 쿼리를 사용하여 성능 향상 가능

### 인덱스 스캔을 사용한 정렬

- 인덱스 항목 간에 이동만 하면 되므로 인덱스 자체를 검색하는 것이 빠름
- MySQL은 행을 정렬하고 찾는 데 모두 동일한 인덱스 사용 가능
- ORDER BY 지정 시 가장 왼쪽 접두사를 기준으로 지정해야 함

### 중복과 이중 인덱스

- 중복 인덱스는 생성 가능 하지만 방지는 불가
- 대부분은 중복 인덱스는 성능을 하락 -> 차라리 인덱스를 확장하는 것이 나음
- 정수 열에 인덱스가 있고 VARCHAR 열을 사용할 경우 속도가 느려질 수 있음
- 가끔 인덱스 중복 생성이 나을 경우도 있는데, 두 쿼리에 대한 성능 모두 포기 못하는 경우
- 다만 인덱스가 2개 이상 있을 경우 유지 관리 비용이 매우 큼
    - 데이터 insert time이 커짐

### 사용하지 않는 인덱스

- 서버에서 사용하지 인덱스는 제거 필요
- *performance_schema* 및 *sys*를 사용하여 사용되지 않는 테이블 뷰 확인

## 인덱스와 테이블 유지 관리

- 테이블 유지 관리의 주요 목표는 손상 발견 수정 및 정밀한 인덱스 통계 유지 및 조각화 감소

### 테이블 손상 찾기 및 복구

- 인덱스가 손상될 경우 쿼리가 잘못 된 결과를 반환 하거나 잠금 및 충돌 발생 가능
- *REPAIR TABLE* 명령을 사용하여 손상된 테이블을 복구 가능 하지만 대부분 스토리지 엔진에서는 이를 지원하지 않음
- 따라서 아무런 영향을 끼치지 않는 ALTER 명령문을 사용하여 데이터를 덤프하고 로드하면서 인덱스 영역의 손상 탐지 가능
- inno_force_recovery 변수를 사용하여 강제 복구 모드로 전환하여 복구할 수 있음

### 인덱스 통계 업데이트

- 비용을 기반으로 하여 쿼리가 엑세스할 데이터 양을 조회
- *ANALYZE TABLE*을 실행하여 검사 가능
- InnoDB는 테이블을 처음 열었을 때, 테이블 크기가 크게 변경되었을 때 또한 통계 계산
- 다만 데이터가 많은 대규모 서버나 I/O가 느린 경우는 심각한 문제가 될 수도 있음

### 인덱스 및 데이터 단편화 줄이기

- B-트리 인덱스가 조각화 되어 성능이 저하 될 수 있음
- 설계상 B-트리 인덱스의 랜덤 엑세스는 규칙
- 다만 리프 페이지가 순차적이고 빽빽할 경우 더 나은 성능 낼 수 있음
- 데이터 단편화는 인덱스 단편화 보다 복잡
    - 행 단편화
    - 행 내부 단편화
    - 여유 공간 단편화
- 데이터 덤프 후 다시 로드 시 위 문제에 대해 조각 모음 수행