# 9장 복제

- MySQL 내장 복제 기능은 **Scale Out** 이라는 아키텍처를 사용하여 고성능 어플리케이션을 구축
- 복제는 고가용성, 확장성, 재해 복구, 백업, 분석, 데이터 웨어하우징
- 반동기 복제, 다중 소스 복제에 대해 설명

## 복제 개요

- 가장 기본 적인 방법
    - 동일한 토폴로지 내의 데이터베이스 인스턴스 간에 데이터를 계속해서 동기화
    - 이로 인한 레플리카 지연의 가능성은 무한히 가능
- MySQL의 복제는 대부분 이전 버전과 호환
    - 다만 상위 호환성은 장담 불가
- 전체 시스템이 가장 약한 부분이 수행 할 수 있는 쓰기 횟수로 제한
- 복제의 사용 방법
    - 데이터 분산
        - 레플리카의 데이터 지연 시간을 줄이고, 복제를 언제든 재시작 
    - 읽기 트래픽 확장
        - 읽기 쿼리를 여러 서버로 분산해서 트래픽 감소
    - 백업
    - 분석 및 보고
        - 분석 용 OLAP DB로 사용
    - 고가용성 및 장애 조치
        - MySQL이 단일 장애 지점이 되는 것을 방지 가능
    - MySQL 업그레이드 테스트

### 복제 작동 방식

- MySQL이 데이터를 복제하는 방법
    - 3단계 프로세스
        1. 소스는 데이터를 '바이너리 로그 이벤트'로 기록
        2. 레플리카는 위 정보를 로컬 릴레이 로그에 복사
        3. 릴레이 로그의 이벤트를 재생하여 변경 사항 적용

## 복제의 내부 동작

- 복제 구성을 위한 고급 옵션 확인

### 복제 형식 선택

- 복제를 위해 제공하는 바이너리 로그 형식
    - 명령문 기반
        - 문제점 : 비결정적 쿼리로 인한 레플리카와 메인 DB의 불일치 데이터 삭제
    - 행 기반
        - 문제점 : 모든 행에 대해 작성할 경우 바이너리 로그 크기가 크게 증대
    - 혼합 기반
        - 명령문 방식을 기본으로 필요할 때만 행 방식 사용
- 일시적으로 명령문 기반이 아닌 경우 행 기반 복제가 안전

### 전역 트랜잭션 식별자

- MySQL에서는 복제 위치 추적 방법으로 GTID(전역 트랜잭션 식별자)를 추가
- 트랜잭션이 기록되면 GTID 또한 같이 기록되면서 레플리카에도 같은 방식으로 적용
- GTID는 로그 파일과 위치로 처리하던 부분을 해결

### 복제 충돌의 대비

- 복제 사용 환경을 개선할 수 있는 정보
    - inno_flush_log_at_trx_commit = 1
        - 각 트랜잭션 별로 로그를 기록하고 디스크에 동기화하는 설정
        - 바이너리 로그 이벤트가 먼저 커밋된 다음 트랜잭션이 커밋
    - sync_binlog = 1
        - MySQL이 바이너리 로그 데이터에 동기화하는 빈도 - 1의 경우 모든 트랜잭션
    - relay_log_linfo_repository = TABLE
        - 디스크의 파일을 사용하여 복제 위치를 추적하는 데에 사용
        - InnoDB 테이블에 트랜잭션과 릴레이 로그 정보 업데이트
    - relay_log_recovery = ON
        - 디스크 충돌 시 발생할 수 있는 디스크 손상 및 디스크 릴레이 복구 가능 옵션
        - 이를 위한 추가 작업 불필요

### 지연 복제

- 토폴로지에 지연된 레프리카가 있는 것이 유리할 수 도 있음
- GTID를 찾아 복제를따라잡을 수 있어 교정 시간이 있을 수 있음
- 다만 운영 측면에서의 복잡성을 초래

### 멀티 스레드 복제

- MySQL은 멀티 스레드 복제에는 *DATABASE* 및 *LOGICAL_CLOCK*의 두 가지 모드가 있음
    - DATABASE 모드
        - 여러 스레드를 사용해서 서로 다른 데이터베이스 업데이트
    - LOGICAL_CLOCK
        - 바이너리 로그 그룹 커밋 단위로 동일 데이터베이스에 대한 병렬 업데이트 수행
- replica_parallel_workers를 0이 아닌 값으로 설정하면 사용 가능
- 단일 DB 작업 시 replica_preserve_type을 *LOGICAL_CLOCK*로 변경 필요
- replica_parallel_workers 값을 결정하는 방법은 각기 다른 개수로 소요 시간 측정


```
바이너리 로그 그룹 커밋

- MySQL 5.0
    - A -> B로 승객 이동 시 기다리는 것들만 이동
- MySQL 5.6
    - A -> B로 승객 이동 시 대기 중인 모든 승객을 태움
- MySQL 5.7 이후
    - 새로운 승각이 도착할 것을 알고 조금 대기
- 이에 대한 환경 변수는 binlog_group_commit_sync_delay (단위 지연)
```

### 반동기 복제

- 소스를 커밋하는 트랜잭션은 하나 이상의 레플리카에서 수신 확인 필요
- 수행하는 모든 트랜잭션에 대기 시간을 추가
- 일정 기간에 트랜 잭션을 승인하는 레플리카가 없으면 표준 비동기식 복제로 돌아감
    - 탄력적인 페일 오버 수행할 수 있는 구성 요소

### 복제 필터

- 복제 필터의 구성
    - 바이너리 로그에서 이벤트를 필터
        - *binlog_do_db* 및 *binlog_ignor_db*를 통해 필터링 제어가 가능하지만, 가급적 활성화 비추천
    - 릴레이 로그에서 이벤트를 필터
        - *replica_* 옵션은 이벤트를 필터링
- 복제 필터가 유용한 상황
    - 성능에 영향을 줄 수 있는 상태에 있는 옵션에 대해 복제 규칙을 설정하여 제외하는 방식

## 복제 페일 오버

- 고가용성을 유지 하기 위해 레플리카를 원본 노드로 승격하는 방법

### 계획된 승격

- *통제된 승격* / *계획된 승격*
- 프로세스 단계
    1. 승격 레플리카 결정
    2. 지연 확인
    3. 소스 쓰기 중단
    4. 동기화 대기 GTID 비교 및 확인
    5. read_only를 설정 해제
    6. 트래픽을 해당 시스템으로 향하게 변경
    7. 모든 레플리카를 새 소스로 다시 지정
        - GTID 및 AUTO_POSITION = 1

### 계획되지 않은 승격

- 소프트웨어 또는 하드웨어로 인한 장애 발생 시 오류를 반환하고 사용자로 하여금 재시작 요청
- 프로세스 단계
    1. 승격한 레플리카 결정
    2. read_only 설정 해제
    3. 애플리케이션 트래픽을 대상으로 향하게 변경
    4. 모든 레플리카를 새 소스로 다시 지정

### 승격의 트레이드 오프

- 다운 타임의 첫번째 대응은 페일 오버
- 다만 누락된 데이터 파악 때문에 하지 않는 것이 나을 수 있음
- 레플리카 검사해서 어느 것이 적합한지 확인하는 데에 드는 cost가 문제가 될 수 있음

## 복제 토폴로지

- 복제 토폴로지 설정 전략

### 액티브/패시브

- 모든 읽기 및 쓰기를 단일 소스 서버로 내보냄
- 소수의 레플리카를 유지 관리
- 복제 지연에 신경 쓰지 않고 싶을 때 사용

#### 구성

- 해당 토폴리지 기준 소스와 레플리카는 CPU, 메모리가 동일
- 따라서 레플리카는 페일오버 시 동일한 처리 가능

#### 중복성

- 물리적인 하드웨어 환경에서는 n + 2 중복이 필요
- n + 1은 복제가 쉬운 경우
- 패치의 경우 세 번째 레플리카를 선 패치 이후에 다른 레플리카로 교체


#### 주의사항

- 읽기 확장을 제한에 도달하면 샤딩을 활용하여 소스 읽기를 줄여야 함

### 액티브/리드 풀

- 모든 쓰기를 소스로 내보냄
- 읽기를 수평으로 확장 가능

#### 구성

- 원본과 레플리카 간에 구성을 동일한 것이 이상적
    - 레플리카는 트래픽을 감당할 수 있는 용량을 지녀야 함

#### 중복성

- 하나 이상의 서버가 페일 오버로 작동 가능
- 읽기 트래픽을 수용할 수 있는 노드 장애에 대비한 작은 버퍼 필요
- 풀의 노드당 사용률을 50% ~ 60% 목표로 설정
- CPU가 증가할 수록 CONTEXT SWITCHING 비용 증가

#### 주의 사항

- state read(과거 데이터 읽을 가능성 존재)를 어느 정도 허용
- 레플리카 복제에 대한 보장 X

### 권장되지 않는 토폴로지

- 많은 복잡성과 위험을 동반하는 설정

#### 액티브-액티브 모드 이중 소스

- 공동 소스로 구성된 두대의 서버
- 쓰기 트래픽을 양쪽에 보내는 액티브/액티브 부분
- 두 서버 간 조절의 문제 때문에 관리가 어려움

#### 액티브-패시브 모드의 이중 소스

- 복제가 다른 서버로 구성되어 있기 때문에 운영 중단 상황에서 유연성 제공 X

#### 레플리카가 있는 이중 소스

- 액티브/액티브 문제 + 데이터 엑세스 문제 발생 가능

#### 링 복제

- 하나라도 오프라인으로 전환될 경우 모든 레플리카 변형 가능
- 장점이 없음

#### 다중 소스 복제

- 동일한 소스에 대해 여러 번 사용하도록 레플리카 구성 X
- 특수 환경에서만 사용 권장 (데이터 병합)

## 복제 관리 및 유지 관리

### 복제 모니터링
### 복제 지연 측정
### 레플리카와 소스의 일치 여부 확인

## 복제 문제와 해법

### 소스의 바이너리 로그 손상
### 고유하지 않은 서버 ID
### 정의되지 않은 서버 ID
### 임시 테이블 누락
### 모든 업데이트를 복제하지 않음
### 과도한 복제 지연
### 소스의 오버사이즈 패킷
### 디스크 공간 없음
### 복제 제한 사항