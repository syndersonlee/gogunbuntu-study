# 9장 복제

- MySQL 내장 복제 기능은 **Scale Out** 이라는 아키텍처를 사용하여 고성능 어플리케이션을 구축
- 복제는 고가용성, 확장성, 재해 복구, 백업, 분석, 데이터 웨어하우징
- 반동기 복제, 다중 소스 복제에 대해 설명

## 복제 개요

- 가장 기본 적인 방법
    - 동일한 토폴로지 내의 데이터베이스 인스턴스 간에 데이터를 계속해서 동기화
    - 이로 인한 레플리카 지연의 가능성은 무한히 가능
- MySQL의 복제는 대부분 이전 버전과 호환
    - 다만 상위 호환성은 장담 불가
- 전체 시스템이 가장 약한 부분이 수행 할 수 있는 쓰기 횟수로 제한
- 복제의 사용 방법
    - 데이터 분산
        - 레플리카의 데이터 지연 시간을 줄이고, 복제를 언제든 재시작 
    - 읽기 트래픽 확장
        - 읽기 쿼리를 여러 서버로 분산해서 트래픽 감소
    - 백업
    - 분석 및 보고
        - 분석 용 OLAP DB로 사용
    - 고가용성 및 장애 조치
        - MySQL이 단일 장애 지점이 되는 것을 방지 가능
    - MySQL 업그레이드 테스트

### 복제 작동 방식

- MySQL이 데이터를 복제하는 방법
    - 3단계 프로세스
        1. 소스는 데이터를 '바이너리 로그 이벤트'로 기록
        2. 레플리카는 위 정보를 로컬 릴레이 로그에 복사
        3. 릴레이 로그의 이벤트를 재생하여 변경 사항 적용

## 복제의 내부 동작

- 복제 구성을 위한 고급 옵션 확인

### 복제 형식 선택

- 복제를 위해 제공하는 바이너리 로그 형식
    - 명령문 기반
        - 문제점 : 비결정적 쿼리로 인한 레플리카와 메인 DB의 불일치 데이터 삭제
    - 행 기반
        - 문제점 : 모든 행에 대해 작성할 경우 바이너리 로그 크기가 크게 증대
    - 혼합 기반
        - 명령문 방식을 기본으로 필요할 때만 행 방식 사용
- 일시적으로 명령문 기반이 아닌 경우 행 기반 복제가 안전

### 전역 트랜잭션 식별자

- MySQL에서는 복제 위치 추적 방법으로 GTID(전역 트랜잭션 식별자)를 추가
- 트랜잭션이 기록되면 GTID 또한 같이 기록되면서 레플리카에도 같은 방식으로 적용
- GTID는 로그 파일과 위치로 처리하던 부분을 해결

### 복제 충돌의 대비

- 복제 사용 환경을 개선할 수 있는 정보
    - inno_flush_log_at_trx_commit = 1
        - 각 트랜잭션 별로 로그를 기록하고 디스크에 동기화하는 설정
        - 바이너리 로그 이벤트가 먼저 커밋된 다음 트랜잭션이 커밋
    - sync_binlog = 1
        - MySQL이 바이너리 로그 데이터에 동기화하는 빈도 - 1의 경우 모든 트랜잭션
    - relay_log_linfo_repository = TABLE
        - 디스크의 파일을 사용하여 복제 위치를 추적하는 데에 사용
        - InnoDB 테이블에 트랜잭션과 릴레이 로그 정보 업데이트
    - relay_log_recovery = ON
        - 디스크 충돌 시 발생할 수 있는 디스크 손상 및 디스크 릴레이 복구 가능 옵션
        - 이를 위한 추가 작업 불필요

### 지연 복제

- 토폴로지에 지연된 레프리카가 있는 것이 유리할 수 도 있음
- GTID를 찾아 복제를따라잡을 수 있어 교정 시간이 있을 수 있음
- 다만 운영 측면에서의 복잡성을 초래

### 멀티 스레드 복제

- MySQL은 멀티 스레드 복제에는 *DATABASE* 및 *LOGICAL_CLOCK*의 두 가지 모드가 있음
    - DATABASE 모드
        - 여러 스레드를 사용해서 서로 다른 데이터베이스 업데이트
    - LOGICAL_CLOCK
        - 바이너리 로그 그룹 커밋 단위로 동일 데이터베이스에 대한 병렬 업데이트 수행
- replica_parallel_workers를 0이 아닌 값으로 설정하면 사용 가능
- 단일 DB 작업 시 replica_preserve_type을 *LOGICAL_CLOCK*로 변경 필요
- replica_parallel_workers 값을 결정하는 방법은 각기 다른 개수로 소요 시간 측정


```
바이너리 로그 그룹 커밋

- MySQL 5.0
    - A -> B로 승객 이동 시 기다리는 것들만 이동
- MySQL 5.6
    - A -> B로 승객 이동 시 대기 중인 모든 승객을 태움
- MySQL 5.7 이후
    - 새로운 승각이 도착할 것을 알고 조금 대기
- 이에 대한 환경 변수는 binlog_group_commit_sync_delay (단위 지연)
```

### 반동기 복제

- 소스를 커밋하는 트랜잭션은 하나 이상의 레플리카에서 수신 확인 필요
- 수행하는 모든 트랜잭션에 대기 시간을 추가
- 일정 기간에 트랜 잭션을 승인하는 레플리카가 없으면 표준 비동기식 복제로 돌아감
    - 탄력적인 페일 오버 수행할 수 있는 구성 요소

### 복제 필터

- 복제 필터의 구성
    - 바이너리 로그에서 이벤트를 필터
        - *binlog_do_db* 및 *binlog_ignor_db*를 통해 필터링 제어가 가능하지만, 가급적 활성화 비추천
    - 릴레이 로그에서 이벤트를 필터
        - *replica_* 옵션은 이벤트를 필터링
- 복제 필터가 유용한 상황
    - 성능에 영향을 줄 수 있는 상태에 있는 옵션에 대해 복제 규칙을 설정하여 제외하는 방식

## 복제 페일 오버

- 고가용성을 유지 하기 위해 레플리카를 원본 노드로 승격하는 방법

### 계획된 승격

- *통제된 승격* / *계획된 승격*
- 프로세스 단계
    1. 승격 레플리카 결정
    2. 지연 확인
    3. 소스 쓰기 중단
    4. 동기화 대기 GTID 비교 및 확인
    5. read_only를 설정 해제
    6. 트래픽을 해당 시스템으로 향하게 변경
    7. 모든 레플리카를 새 소스로 다시 지정
        - GTID 및 AUTO_POSITION = 1

### 계획되지 않은 승격

- 소프트웨어 또는 하드웨어로 인한 장애 발생 시 오류를 반환하고 사용자로 하여금 재시작 요청
- 프로세스 단계
    1. 승격한 레플리카 결정
    2. read_only 설정 해제
    3. 애플리케이션 트래픽을 대상으로 향하게 변경
    4. 모든 레플리카를 새 소스로 다시 지정

### 승격의 트레이드 오프

- 다운 타임의 첫번째 대응은 페일 오버
- 다만 누락된 데이터 파악 때문에 하지 않는 것이 나을 수 있음
- 레플리카 검사해서 어느 것이 적합한지 확인하는 데에 드는 cost가 문제가 될 수 있음

## 복제 토폴로지

- 복제 토폴로지 설정 전략

### 액티브/패시브

- 모든 읽기 및 쓰기를 단일 소스 서버로 내보냄
- 소수의 레플리카를 유지 관리
- 복제 지연에 신경 쓰지 않고 싶을 때 사용

#### 구성

- 해당 토폴리지 기준 소스와 레플리카는 CPU, 메모리가 동일
- 따라서 레플리카는 페일오버 시 동일한 처리 가능

#### 중복성

- 물리적인 하드웨어 환경에서는 n + 2 중복이 필요
- n + 1은 복제가 쉬운 경우
- 패치의 경우 세 번째 레플리카를 선 패치 이후에 다른 레플리카로 교체


#### 주의사항

- 읽기 확장을 제한에 도달하면 샤딩을 활용하여 소스 읽기를 줄여야 함

### 액티브/리드 풀

- 모든 쓰기를 소스로 내보냄
- 읽기를 수평으로 확장 가능

#### 구성

- 원본과 레플리카 간에 구성을 동일한 것이 이상적
    - 레플리카는 트래픽을 감당할 수 있는 용량을 지녀야 함

#### 중복성

- 하나 이상의 서버가 페일 오버로 작동 가능
- 읽기 트래픽을 수용할 수 있는 노드 장애에 대비한 작은 버퍼 필요
- 풀의 노드당 사용률을 50% ~ 60% 목표로 설정
- CPU가 증가할 수록 CONTEXT SWITCHING 비용 증가

#### 주의 사항

- state read(과거 데이터 읽을 가능성 존재)를 어느 정도 허용
- 레플리카 복제에 대한 보장 X

### 권장되지 않는 토폴로지

- 많은 복잡성과 위험을 동반하는 설정

#### 액티브-액티브 모드 이중 소스

- 공동 소스로 구성된 두대의 서버
- 쓰기 트래픽을 양쪽에 보내는 액티브/액티브 부분
- 두 서버 간 조절의 문제 때문에 관리가 어려움

#### 액티브-패시브 모드의 이중 소스

- 복제가 다른 서버로 구성되어 있기 때문에 운영 중단 상황에서 유연성 제공 X

#### 레플리카가 있는 이중 소스

- 액티브/액티브 문제 + 데이터 엑세스 문제 발생 가능

#### 링 복제

- 하나라도 오프라인으로 전환될 경우 모든 레플리카 변형 가능
- 장점이 없음

#### 다중 소스 복제

- 동일한 소스에 대해 여러 번 사용하도록 레플리카 구성 X
- 특수 환경에서만 사용 권장 (데이터 병합)

## 복제 관리 및 유지 관리

- 데이터베이스는 시간이 갈수록 크기가 커짐으로 유지 관리가 필요

### 복제 모니터링

- 복제는 모니터링의 복잡성 증대
- 복제 모니터링 시 중요하게 고려해야하는 항목
    - 복제는 소스와 레플리카 디스크 공간 모두 필요
        - 트랜잭션 처리에 대한 공간 필요
    - 복제는 상태 및 오류 모니터링
        - 네트워크 문제, 데이터 손상 같은 외부 요인으로 인한 복제 중단 여부 확인 모니터링
    - 지연 복제는 그대로 지연 처리
        - 예상한 지연 시간을 따라야 함

### 복제 지연 측정

- 모니터링 시 소스 <-> 레플리카의 데이터 차이를 관측해야 함
- 하지만 정확하지는 않음
    - 레플리카는 서버에 타임스탬프와 바이너리 로그
    - 복제 미실행 시 NULL 보고
    - 일부 오류는 복제를 중단하거나 복제 스레드를 중지할 수 있지만 오류를 미 표시
    - 레플리카 지연을 계산하지 못하는 경우
    - 트랜잭션이 매우 긴 경우, 지연이 바뀜

### 레플리카와 소스의 일치 여부 확인

- 레플리카 데이터 불일치가 레플리카에 존재 가능
    - 레플리카에 실수로 쓰기
    - 양쪽이 쓰기를 수행하는 이중 소스 복제 사용
    - 비결정적 쿼리 및 명령문 기반 복제
    - 지속성이 낮은 모드 시 MySQL의 충돌
- 아래와 같은 규칙 제시
    - super_read_only가 활성화 된 상태에서 레플리카 상태에서 레플리카를 실행
        - 복제에서 쓰기만 설정
    - 행 기반 복제 또는 결정론적 구문 사용
    - 복제 토폴로지에서 여러 서버에 동시 쓰기 방지

## 복제 문제와 해법

### 소스의 바이너리 로그 손상

- 바이너리 로그가 손상 시 레플리카 재구성 만이 답

### 고유하지 않은 서버 ID

- innotop 도구나 오류 로그를 통해 어느 레플리카 연결 여부인지를 확인
- 느리게 복제되거나 복제 되지 않은 케이스 발생 가능
- 해결책
    - 레플리카 설정 시 주의
    - IP 주소 등을 옥텟으로 사용하는 방법

### 정의되지 않은 서버 ID

- 서버 ID를 명확하게 명시

### 임시 테이블 누락

- 레플리카 충돌 시 임시 테이블은 삭제 가능성이 존재
- 명령문 기반 복제 X
- 해결책
    - 행 기반 복제 사용
    - 임시 테이블 이름을 일관 되게 지정하여 복제 건너뜀

### 모든 업데이트를 복제하지 않음

- 설정을 잘못 쓰거나 복제 필터링 규칙 이해 못할 시 업데이트 X

### 과도한 복제 지연

- 자주 발생하는 복제 지연
- 다만 이를 줄이기 위한 접근 방식 존재
    - 멀티 스레드 복제
    - 샤딩 사용
    - 일시적인 지속성 저하
        - 위 방식 시 레플리카에서만 설정 수행하고, 백업 역할일 경우 복구 불가 가능성 존재
        - Seconds_behind_source 값을 확인하고 이를 트리거

### 소스의 오버사이즈 패킷

- 레플리카와 최대 패킷 크기가 다를 경우 발생 가능
- 오류 무한 루프 발생 가능

### 디스크 공간 없음

- 임시 파일로 디스크를 다 채울 수 있음
- 디스크 사용량을 꾸준히 모니터링 필요

### 복제 제한 사항

- 고유한 제한 사항으로 인한 복제 불가
- 서버 버그로 인한 복제 버그 발생

## 질문 답


- p287 모든 업데이트를 복제하지 않음 의 해결 방법은 어떤 걸까요?!
```
책에서 나와 있는 SET SQL_LOG_BIN = 0의 의미
->  sql_log_bin 변수는 현재 세션에 대해 바이너리 로그에 대한 로깅을 활성화할지 여부를 제어합니다(바이너리 로그 자체가 활성화되어 있다고 가정). 
기본값은 켜짐입니다. 현재 세션에 대한 이진 로깅을 비활성화하거나 활성화하려면 세션 sql_log_bin 변수를 OFF 또는 ON으로 설정합니다.
복제본에 복제하지 않으려는 소스를 변경하는 동안 세션에서 이진 로깅을 일시적으로 비활성화하려면 이 변수를 OFF로 설정합니다.

- MySQL이 데이터를 복제하는 방법
    - 3단계 프로세스
        1. 소스는 데이터를 '바이너리 로그 이벤트'로 기록
        2. 레플리카는 위 정보를 로컬 릴레이 로그에 복사
        3. 릴레이 로그의 이벤트를 재생하여 변경 사항 적용

위 두 내용으로 SQL_LOG_BIN = 0 세팅 및 복제 필터링의 문제로 바이너리 로그 미 적재 -> 바이너리 로그가 없으므로 레플리카에서는 복사 불가
```

- 바이너리 로그와 릴레이 로그는 뭘까요? (어떤 데이터가 저장되는지, 어떤 차이점이 있는지?)
```
마스터에 저장되는 것 = 바이너리 로그
슬레이브에 저장되는 것 = 릴레이 로그

+@
Binary logs are used to record all changes to the database, including insertions, updates, and deletions, in a binary format. These logs are generated by the MySQL server and can be used for a variety of purposes, including disaster recovery, auditing, and replication.
On the other hand, relay logs are created by the slave server as a temporary storage location for the events received from the master server. Relay logs are created and used only during replication, and their primary function is to store events that have been received from the master server and to apply them to the slave`s local copy of the database.
In summary, binary logs record all changes made to the database, while relay logs store events received from the master server during replication.
```

- 바이러니 로그 그룹 커밋이 그래서 뭘까요? (비유를 읽어도 명확히 이해가 되지 않네요..)
```
한 번의 여러 커밋 요청을 처리함으로써 초당 커밋 수를 크게 늘리는 방법으로 성능을 개선
트랜잭션이 커밋되거나 커밋되지 않도록 하여 복제의 안정성을 향상시킬 수 있습니다. 
데이터 불일치를 방지하고 슬레이브 서버가 마스터 데이터베이스의 정확한 사본을 갖도록 보장
```
!(추가 자료)[http://mysqlmusings.blogspot.com/2012/06]

- 280p "액티브/패시브 권장 사항과 다른 유일한 점은 ..." 이 이해가 되지 않습니다. 뭐가 다른 건가요?
```
해당 그림에는 소스 -> 레플리카 관계를 액티브 -> 패시브로 바꾼 관계 패시브 = 서버 구성이 다른 레플리카
다른 점은 소스 구성이 액티브에 전부 존재하는 것이 아닌 이를 분배했다는 점

The main problem with this topology is that it can create data inconsistencies and conflicts when the active source fails and the passive source takes over. When the passive source becomes active, it may have a different set of data than the previously active source, which can lead to conflicts and inconsistencies.
```